{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"home/","text":"#DevopsTraineeProgram This repository is used to document the journey for the Devops Trainee program to build foundational knowledge of DevOps. The goal is to tackle each topic through sprints to tackle over 13 areas of DevOps to a foundational knowledge for a full-time position in Resultier. This will not cover all things DevOps but it will cover the areas that will benefit your learning and understanding overall to tackle our end projects. #Week 00 [\u2714\ufe0f] Day 00 \u267e\ufe0f 01 > Introduction #Week 01 What is and why do we use DevOps [\u2714\ufe0f] \u267e\ufe0f 01 > Responsibilities of a DevOps Engineer [\u2714\ufe0f] \u267e\ufe0f 02 > DevOps Lifecycle - Application Focused [\u2714\ufe0f] \u267e\ufe0f 03 > DevOps & Agile [\u2714\ufe0f] \u267e\ufe0f 04 > Plan > Code > Build > Testing > Release > Deploy > Operate > Monitor > [\u2714\ufe0f] \u267e\ufe0f 05 > DevOps - The real stories Learning a Programming Language [\ud83d\udea7] \u2328\ufe0f 06 > The Big Picture: DevOps & Learning a Programming Language [\ud83d\udea7] \u2328\ufe0f 07 > Setting up your DevOps environment for Go & Hello World [\ud83d\udea7] \u2328\ufe0f 08 > Let's explain the Hello World code [\ud83d\udea7] \u2328\ufe0f 09 > The Go Workspace & Compiling & running code [\ud83d\udea7] \u2328\ufe0f 10 > Variables, Constants & Data Types [\ud83d\udea7] \u2328\ufe0f 11 > Getting user input with Pointers and a finished program [\ud83d\udea7] \u2328\ufe0f 12 > Tweet your progress with our new App Knowing Linux Basics [\ud83d\udea7] \ud83d\udc27 13 > The Big Picture: DevOps and Linux [\ud83d\udea7] \ud83d\udc27 14 > Linux Commands for DevOps (Actually everyone) [\ud83d\udea7] \ud83d\udc27 15 > Managing your Linux System, Filesystem & Storage [\ud83d\udea7] \ud83d\udc27 16 > Text Editors - nano vs vim [\ud83d\udea7] \ud83d\udc27 17 > SSH & Web Server(LAMP) [\ud83d\udea7] \ud83d\udc27 18 > Automate tasks with bash scripts [\ud83d\udea7] \ud83d\udc27 19 > Dev workstation setup - All the pretty things #Week 02 Understand Networking [\ud83d\udea7] \ud83c\udf10 01 > The Big Picture: DevOps and Networking [\ud83d\udea7] \ud83c\udf10 02 > The OSI Model - The 7 Layers [\ud83d\udea7] \ud83c\udf10 03 > Network Protocols [\ud83d\udea7] \ud83c\udf10 04 > Network Automation [\ud83d\udea7] \ud83c\udf10 05 > Python for Network Automation [\ud83d\udea7] \ud83c\udf10 06 > Building our Lab [\ud83d\udea7] \ud83c\udf10 07 > Getting Hands-On with Python & Network Stick to one Cloud Provider [\ud83d\udea7] \u2601\ufe0f 01 > The Big Picture: DevOps & The Cloud [\ud83d\udea7] \u2601\ufe0f 02 > Cloud Fundamentals [\ud83d\udea7] \u2601\ufe0f 03 > Cloud Security Models [\ud83d\udea7] \u2601\ufe0f 04 > Cloud Compute Models [\ud83d\udea7] \u2601\ufe0f 05 > Cloud Storage & Database Models [\ud83d\udea7] \u2601\ufe0f 06 > Cloud Networking Models + Azure Management [\ud83d\udea7] \u2601\ufe0f 07 > Cloud Hands-On Scenarios Use Git Effectively [\ud83d\udea7] \ud83d\udcda 01 > The Big Picture: Git - Version Control [\ud83d\udea7] \ud83d\udcda 02 > Installing & Configuring Git [\ud83d\udea7] \ud83d\udcda 03 > Gitting to know Git [\ud83d\udea7] \ud83d\udcda 04 > Staging & Changing [\ud83d\udea7] \ud83d\udcda 05 > Viewing, unstaging, discarding & restoring [\ud83d\udea7] \ud83d\udcda 06 > Social Network for code [\ud83d\udea7] \ud83d\udcda 07 > The Open Source Workflow #Week 03 Containers [\ud83d\udea7] \ud83c\udfd7\ufe0f 01 > The Big Picture: Containers [\ud83d\udea7] \ud83c\udfd7\ufe0f 02 > What is Docker & Getting installed [\ud83d\udea7] \ud83c\udfd7\ufe0f 03 > Docker Images & Hands-On with Docker Desktop [\ud83d\udea7] \ud83c\udfd7\ufe0f 04 > The anatomy of a Docker Image [\ud83d\udea7] \ud83c\udfd7\ufe0f 05 > Docker Compose [\ud83d\udea7] \ud83c\udfd7\ufe0f 06 > Docker Networking & Security [\ud83d\udea7] \ud83c\udfd7\ufe0f 07 > Alternatives to Docker #Week 04 Kubernetes [\ud83d\udea7] \u2638 01 > The Big Picture: Kubernetes [\ud83d\udea7] \u2638 02 > Choosing your Kubernetes platform [\ud83d\udea7] \u2638 03 > Deploying your first Kubernetes Cluster [\ud83d\udea7] \u2638 04 > Setting up a multinode Kubernetes Cluster [\ud83d\udea7] \u2638 05 > Helm Overview - Hands On [\ud83d\udea7] \u2638 06 > Kubernetes Application Deployment [\ud83d\udea7] \u2638 07 > State and Ingress in Kubernetes #Week 05 Learn Infrastructure as Code [\ud83d\udea7] \ud83e\udd16 01 > The Big Picture: IaC [\ud83d\udea7] \ud83e\udd16 02 > An intro to Terraform [\ud83d\udea7] \ud83e\udd16 03 > HashiCorp Configuration Language (HCL) [\ud83d\udea7] \ud83e\udd16 04 > Create a VM with Terraform & Variables [\ud83d\udea7] \ud83e\udd16 05 > Docker Containers, Provisioners & Modules [\ud83d\udea7] \ud83e\udd16 06 > Kubernetes & Multiple Environments [\ud83d\udea7] \ud83e\udd16 07 > Testing, Tools & Alternatives Automate Configuration Management [\ud83d\udea7] \ud83d\udcdc 01 > The Big Picture: Configuration Management [\ud83d\udea7] \ud83d\udcdc 02 > Ansible: Getting Started [\ud83d\udea7] \ud83d\udcdc 03 > Ansible Playbooks [\ud83d\udea7] \ud83d\udcdc 04 > Ansible Playbooks Continued... [\ud83d\udea7] \ud83d\udcdc 05 > Using Roles & Deploying a Loadbalancer [\ud83d\udea7] \ud83d\udcdc 06 > Tags, Variables, Inventory & Database Server config [\ud83d\udea7] \ud83d\udcdc 07 > All other things Ansible - Automation Controller, AWX, Vault #Week 06 Create CI/CD Pipelines [\ud83d\udea7] \ud83d\udd04 01 > The Big Picture: CI/CD Pipelines [\ud83d\udea7] \ud83d\udd04 02 > What is Jenkins? [\ud83d\udea7] \ud83d\udd04 03 > Getting hands on with Jenkins [\ud83d\udea7] \ud83d\udd04 04 > Building a Jenkins pipeline [\ud83d\udea7] \ud83d\udd04 05 > Hello World - Jenkinsfile App Pipeline [\ud83d\udea7] \ud83d\udd04 06 > GitHub Actions Overview [\ud83d\udea7] \ud83d\udd04 07 > Overview #Week 07 Monitoring, Log Management, and Data Visualisation [\ud83d\udea7] \ud83d\udcc8 01 > The Big Picture: Monitoring [\ud83d\udea7] \ud83d\udcc8 02 > Hands-On Monitoring Tools [\ud83d\udea7] \ud83d\udcc8 03 > The Big Picture: Log Management [\ud83d\udea7] \ud83d\udcc8 04 > ELK Stack [\ud83d\udea7] \ud83d\udcc8 05 > Fluentd & FluentBit [\ud83d\udea7] \ud83d\udcc8 06 > EFK Stack [\ud83d\udea7] \ud83d\udcc8 07 > Data Visualisation - Grafana #Week 08 Store & Protect Your Data [\ud83d\udea7] \ud83d\uddc3\ufe0f 01 > The Big Picture: Data Management [\ud83d\udea7] \ud83d\uddc3\ufe0f 02 > Data Services [\ud83d\udea7] \ud83d\uddc3\ufe0f 03 > Backup all the platforms [\ud83d\udea7] \ud83d\uddc3\ufe0f 04 > Hands-On Backup & Recovery [\ud83d\udea7] \ud83d\uddc3\ufe0f 05 > Application Focused Backups [\ud83d\udea7] \ud83d\uddc3\ufe0f 06 > Disaster Recovery [\ud83d\udea7] \ud83d\uddc3\ufe0f 07 > Data & Application Mobility","title":"#DevopsTraineeProgram"},{"location":"home/#devopstraineeprogram","text":"This repository is used to document the journey for the Devops Trainee program to build foundational knowledge of DevOps. The goal is to tackle each topic through sprints to tackle over 13 areas of DevOps to a foundational knowledge for a full-time position in Resultier. This will not cover all things DevOps but it will cover the areas that will benefit your learning and understanding overall to tackle our end projects.","title":"#DevopsTraineeProgram"},{"location":"home/#week-00","text":"[\u2714\ufe0f] Day 00 \u267e\ufe0f 01 > Introduction","title":"#Week 00"},{"location":"home/#week-01","text":"","title":"#Week 01"},{"location":"home/#what-is-and-why-do-we-use-devops","text":"[\u2714\ufe0f] \u267e\ufe0f 01 > Responsibilities of a DevOps Engineer [\u2714\ufe0f] \u267e\ufe0f 02 > DevOps Lifecycle - Application Focused [\u2714\ufe0f] \u267e\ufe0f 03 > DevOps & Agile [\u2714\ufe0f] \u267e\ufe0f 04 > Plan > Code > Build > Testing > Release > Deploy > Operate > Monitor > [\u2714\ufe0f] \u267e\ufe0f 05 > DevOps - The real stories","title":"What is and why do we use DevOps"},{"location":"home/#learning-a-programming-language","text":"[\ud83d\udea7] \u2328\ufe0f 06 > The Big Picture: DevOps & Learning a Programming Language [\ud83d\udea7] \u2328\ufe0f 07 > Setting up your DevOps environment for Go & Hello World [\ud83d\udea7] \u2328\ufe0f 08 > Let's explain the Hello World code [\ud83d\udea7] \u2328\ufe0f 09 > The Go Workspace & Compiling & running code [\ud83d\udea7] \u2328\ufe0f 10 > Variables, Constants & Data Types [\ud83d\udea7] \u2328\ufe0f 11 > Getting user input with Pointers and a finished program [\ud83d\udea7] \u2328\ufe0f 12 > Tweet your progress with our new App","title":"Learning a Programming Language"},{"location":"home/#knowing-linux-basics","text":"[\ud83d\udea7] \ud83d\udc27 13 > The Big Picture: DevOps and Linux [\ud83d\udea7] \ud83d\udc27 14 > Linux Commands for DevOps (Actually everyone) [\ud83d\udea7] \ud83d\udc27 15 > Managing your Linux System, Filesystem & Storage [\ud83d\udea7] \ud83d\udc27 16 > Text Editors - nano vs vim [\ud83d\udea7] \ud83d\udc27 17 > SSH & Web Server(LAMP) [\ud83d\udea7] \ud83d\udc27 18 > Automate tasks with bash scripts [\ud83d\udea7] \ud83d\udc27 19 > Dev workstation setup - All the pretty things","title":"Knowing Linux Basics"},{"location":"home/#week-02","text":"","title":"#Week 02"},{"location":"home/#understand-networking","text":"[\ud83d\udea7] \ud83c\udf10 01 > The Big Picture: DevOps and Networking [\ud83d\udea7] \ud83c\udf10 02 > The OSI Model - The 7 Layers [\ud83d\udea7] \ud83c\udf10 03 > Network Protocols [\ud83d\udea7] \ud83c\udf10 04 > Network Automation [\ud83d\udea7] \ud83c\udf10 05 > Python for Network Automation [\ud83d\udea7] \ud83c\udf10 06 > Building our Lab [\ud83d\udea7] \ud83c\udf10 07 > Getting Hands-On with Python & Network","title":"Understand Networking"},{"location":"home/#stick-to-one-cloud-provider","text":"[\ud83d\udea7] \u2601\ufe0f 01 > The Big Picture: DevOps & The Cloud [\ud83d\udea7] \u2601\ufe0f 02 > Cloud Fundamentals [\ud83d\udea7] \u2601\ufe0f 03 > Cloud Security Models [\ud83d\udea7] \u2601\ufe0f 04 > Cloud Compute Models [\ud83d\udea7] \u2601\ufe0f 05 > Cloud Storage & Database Models [\ud83d\udea7] \u2601\ufe0f 06 > Cloud Networking Models + Azure Management [\ud83d\udea7] \u2601\ufe0f 07 > Cloud Hands-On Scenarios","title":"Stick to one Cloud Provider"},{"location":"home/#use-git-effectively","text":"[\ud83d\udea7] \ud83d\udcda 01 > The Big Picture: Git - Version Control [\ud83d\udea7] \ud83d\udcda 02 > Installing & Configuring Git [\ud83d\udea7] \ud83d\udcda 03 > Gitting to know Git [\ud83d\udea7] \ud83d\udcda 04 > Staging & Changing [\ud83d\udea7] \ud83d\udcda 05 > Viewing, unstaging, discarding & restoring [\ud83d\udea7] \ud83d\udcda 06 > Social Network for code [\ud83d\udea7] \ud83d\udcda 07 > The Open Source Workflow","title":"Use Git Effectively"},{"location":"home/#week-03","text":"","title":"#Week 03"},{"location":"home/#containers","text":"[\ud83d\udea7] \ud83c\udfd7\ufe0f 01 > The Big Picture: Containers [\ud83d\udea7] \ud83c\udfd7\ufe0f 02 > What is Docker & Getting installed [\ud83d\udea7] \ud83c\udfd7\ufe0f 03 > Docker Images & Hands-On with Docker Desktop [\ud83d\udea7] \ud83c\udfd7\ufe0f 04 > The anatomy of a Docker Image [\ud83d\udea7] \ud83c\udfd7\ufe0f 05 > Docker Compose [\ud83d\udea7] \ud83c\udfd7\ufe0f 06 > Docker Networking & Security [\ud83d\udea7] \ud83c\udfd7\ufe0f 07 > Alternatives to Docker","title":"Containers"},{"location":"home/#week-04","text":"","title":"#Week 04"},{"location":"home/#kubernetes","text":"[\ud83d\udea7] \u2638 01 > The Big Picture: Kubernetes [\ud83d\udea7] \u2638 02 > Choosing your Kubernetes platform [\ud83d\udea7] \u2638 03 > Deploying your first Kubernetes Cluster [\ud83d\udea7] \u2638 04 > Setting up a multinode Kubernetes Cluster [\ud83d\udea7] \u2638 05 > Helm Overview - Hands On [\ud83d\udea7] \u2638 06 > Kubernetes Application Deployment [\ud83d\udea7] \u2638 07 > State and Ingress in Kubernetes","title":"Kubernetes"},{"location":"home/#week-05","text":"","title":"#Week 05"},{"location":"home/#learn-infrastructure-as-code","text":"[\ud83d\udea7] \ud83e\udd16 01 > The Big Picture: IaC [\ud83d\udea7] \ud83e\udd16 02 > An intro to Terraform [\ud83d\udea7] \ud83e\udd16 03 > HashiCorp Configuration Language (HCL) [\ud83d\udea7] \ud83e\udd16 04 > Create a VM with Terraform & Variables [\ud83d\udea7] \ud83e\udd16 05 > Docker Containers, Provisioners & Modules [\ud83d\udea7] \ud83e\udd16 06 > Kubernetes & Multiple Environments [\ud83d\udea7] \ud83e\udd16 07 > Testing, Tools & Alternatives","title":"Learn Infrastructure as Code"},{"location":"home/#automate-configuration-management","text":"[\ud83d\udea7] \ud83d\udcdc 01 > The Big Picture: Configuration Management [\ud83d\udea7] \ud83d\udcdc 02 > Ansible: Getting Started [\ud83d\udea7] \ud83d\udcdc 03 > Ansible Playbooks [\ud83d\udea7] \ud83d\udcdc 04 > Ansible Playbooks Continued... [\ud83d\udea7] \ud83d\udcdc 05 > Using Roles & Deploying a Loadbalancer [\ud83d\udea7] \ud83d\udcdc 06 > Tags, Variables, Inventory & Database Server config [\ud83d\udea7] \ud83d\udcdc 07 > All other things Ansible - Automation Controller, AWX, Vault","title":"Automate Configuration Management"},{"location":"home/#week-06","text":"","title":"#Week 06"},{"location":"home/#create-cicd-pipelines","text":"[\ud83d\udea7] \ud83d\udd04 01 > The Big Picture: CI/CD Pipelines [\ud83d\udea7] \ud83d\udd04 02 > What is Jenkins? [\ud83d\udea7] \ud83d\udd04 03 > Getting hands on with Jenkins [\ud83d\udea7] \ud83d\udd04 04 > Building a Jenkins pipeline [\ud83d\udea7] \ud83d\udd04 05 > Hello World - Jenkinsfile App Pipeline [\ud83d\udea7] \ud83d\udd04 06 > GitHub Actions Overview [\ud83d\udea7] \ud83d\udd04 07 > Overview","title":"Create CI/CD Pipelines"},{"location":"home/#week-07","text":"","title":"#Week 07"},{"location":"home/#monitoring-log-management-and-data-visualisation","text":"[\ud83d\udea7] \ud83d\udcc8 01 > The Big Picture: Monitoring [\ud83d\udea7] \ud83d\udcc8 02 > Hands-On Monitoring Tools [\ud83d\udea7] \ud83d\udcc8 03 > The Big Picture: Log Management [\ud83d\udea7] \ud83d\udcc8 04 > ELK Stack [\ud83d\udea7] \ud83d\udcc8 05 > Fluentd & FluentBit [\ud83d\udea7] \ud83d\udcc8 06 > EFK Stack [\ud83d\udea7] \ud83d\udcc8 07 > Data Visualisation - Grafana","title":"Monitoring, Log Management, and Data Visualisation"},{"location":"home/#week-08","text":"","title":"#Week 08"},{"location":"home/#store-protect-your-data","text":"[\ud83d\udea7] \ud83d\uddc3\ufe0f 01 > The Big Picture: Data Management [\ud83d\udea7] \ud83d\uddc3\ufe0f 02 > Data Services [\ud83d\udea7] \ud83d\uddc3\ufe0f 03 > Backup all the platforms [\ud83d\udea7] \ud83d\uddc3\ufe0f 04 > Hands-On Backup & Recovery [\ud83d\udea7] \ud83d\uddc3\ufe0f 05 > Application Focused Backups [\ud83d\udea7] \ud83d\uddc3\ufe0f 06 > Disaster Recovery [\ud83d\udea7] \ud83d\uddc3\ufe0f 07 > Data & Application Mobility","title":"Store &amp; Protect Your Data"},{"location":"Weeks/00/day01/","text":"Introduction - Week 00 So you want to learn DevOps? Let the journey begin I will share at this point that everyone should have a good look at and maybe create your own mind map for yourself and your interest and position is the following: DevOps Roadmap First Steps - What is DevOps? There are so many blog articles and YouTube videos to list here, but as we start this journey we will focus on spending each topic a day learning something new or about DevOps. We will start with some of the high level of \"what DevOps is\" down to start off this week. Firstly, DevOps is not a tool. You cannot buy it, it is not a software sku or an open source GitHub repository you can download. It is also not a programming language, it is also not some dark art magic either. DevOps is a way to do smarter things in Software Development. DevOps brings together a combination of software development and operations. There are people with all different backgrounds where DevOps is 100% going to benefit the individual, Developers, Operations and QA Engineers all can equally learn these best practices by having a better understanding of DevOps. DevOps is a set of practices that help to reach the goal of this movement: reducing the time between the ideation phase of a product and its release in production to the end-user or whomever it could be an internal team or customer. Another area we will dive into in this first week is around The Agile Methodology DevOps and Agile are widely adopted together to achieve continuous delivery of your Application The high level take away is with a DevOps mindset or culture its about taking a way the long drawn out software release process from potentially years to being able to drop smaller releases more frequently. The other key fundamental to take away here is it's about breaking down silos between the teams I previously mentioned, Developers, Operations and QA. From a DevOps perspective, Development, Testing and Deployment all land with the DevOps team. The final point I will make is to make this as effective and efficient as possible we must leverage Automation Resources My advice is to watch all of the below and hopefully you also picked something up from the text and explanations above. DevOps in 5 Minutes What is DevOps? Easy Way DevOps roadmap 2022 | Success Roadmap 2022 Start your Journey Here Create an account on KodeKloud with your Resultier email. Enroll to DevOps Prerequisites Course Share a screenshot of your progress at the end of the day! See you on the Next Section next week!","title":"1. Introduction"},{"location":"Weeks/00/day01/#introduction-week-00","text":"So you want to learn DevOps?","title":"Introduction - Week 00"},{"location":"Weeks/00/day01/#let-the-journey-begin","text":"I will share at this point that everyone should have a good look at and maybe create your own mind map for yourself and your interest and position is the following: DevOps Roadmap","title":"Let the journey begin"},{"location":"Weeks/00/day01/#first-steps-what-is-devops","text":"There are so many blog articles and YouTube videos to list here, but as we start this journey we will focus on spending each topic a day learning something new or about DevOps. We will start with some of the high level of \"what DevOps is\" down to start off this week. Firstly, DevOps is not a tool. You cannot buy it, it is not a software sku or an open source GitHub repository you can download. It is also not a programming language, it is also not some dark art magic either. DevOps is a way to do smarter things in Software Development. DevOps brings together a combination of software development and operations. There are people with all different backgrounds where DevOps is 100% going to benefit the individual, Developers, Operations and QA Engineers all can equally learn these best practices by having a better understanding of DevOps. DevOps is a set of practices that help to reach the goal of this movement: reducing the time between the ideation phase of a product and its release in production to the end-user or whomever it could be an internal team or customer. Another area we will dive into in this first week is around The Agile Methodology DevOps and Agile are widely adopted together to achieve continuous delivery of your Application The high level take away is with a DevOps mindset or culture its about taking a way the long drawn out software release process from potentially years to being able to drop smaller releases more frequently. The other key fundamental to take away here is it's about breaking down silos between the teams I previously mentioned, Developers, Operations and QA. From a DevOps perspective, Development, Testing and Deployment all land with the DevOps team. The final point I will make is to make this as effective and efficient as possible we must leverage Automation","title":"First Steps - What is DevOps?"},{"location":"Weeks/00/day01/#resources","text":"My advice is to watch all of the below and hopefully you also picked something up from the text and explanations above. DevOps in 5 Minutes What is DevOps? Easy Way DevOps roadmap 2022 | Success Roadmap 2022","title":"Resources"},{"location":"Weeks/00/day01/#start-your-journey-here","text":"Create an account on KodeKloud with your Resultier email. Enroll to DevOps Prerequisites Course Share a screenshot of your progress at the end of the day! See you on the Next Section next week!","title":"Start your Journey Here"},{"location":"Weeks/01/day01-01/","text":"Responsibilities of a DevOps Engineer It was briefly touched on in the first post but now we must get deeper into this concept and understand that there are two main parts when creating an application. We have the Development part where software developers program the application and test it. Then we have the Operations part where the application is deployed and maintained on a server. DevOps is the link between the two To get to grips with DevOps or the tasks in which a DevOps engineer would be carrying out we need to understand the tools or the process and overview of those and how they come together. Everything starts with the application! You will see so much throughout that it is all about the application when it comes to DevOps. Developers will create an application, this can be done with many different technology stacks and lets leave that to the imagination for now as we get into this later. This can also involve many different programming languages, build tools, code repository etc. As a DevOps engineer you won't be programming the application but having a good understanding of the concepts of how a developer works and the systems, tools and processes they are using is key to success. At a very high level you are going to need to know how the application is configured to talk to all of its required services or data services and then also sprinkle a requirement of how this can or should be tested. The application will need to be deployed somewhere, lets keep it generally simple here and make this a server, doesn't matter where but a server. This is then expected to be accessed by the customer or end user depending on the application that has been created. This server needs to run somewhere, on-premises, in a public cloud, serverless. Someone needs to create and configure these servers and get them ready for the application to run. Now this element might land to you as a DevOps engineer to deploy and configure these servers. These servers will have to run an Operating System and generally speaking this is going to be Linux but we have a whole section or week where we cover some of the foundational knowledge you should gain here. It is also likely that we need to communicate with other services in our network or environment, so we also need to have that level of knowledge around networking and configuring that, this might to some degree also land at the feet of the DevOps engineer. Again we will cover this in more detail in a dedicated section talking all things DNS, DHCP, Load Balancing etc. Jack of all trades, Master of none I will say at this point though, you don't need to be a Network or Infrastructure specialist you need a foundational knowledge of how to get things up and running and talking to each other, much the same as maybe having a foundational knowledge of a programming language but you don't need to be a developer. However you might be coming into this as a specialist in an area and that is a great footing to adapt to other areas. You will also most likely not take over the management of these servers or the application on a daily basis. We have been talking about servers but the likelihood is that your application will be developed to run as containers, Which still runs on a server for the most part but you will also need an understanding of not only virtualisation, Cloud Infrastructure as a Service (IaaS) but also containerization as well, this program will be focused and be catered towards containers. High Level Overview On one side we have our developers creating new features and functionality (as well as bug fixes) for the application. On the other side we have some sort of environment, infrastructure or servers which are configured and managed to run this application and communicate with all its required services. The big question is how do we get those features and bug fixes into our production and make it available to those end users? How do we release the new application version? This is one of the main tasks for a DevOps engineer, and the important thing here is not to just figure out how to do this once but we need to do this continuously and in an automated, efficient way which also needs to include testing! This is where we are going to end this day of learning, hopefully this was useful. Over the next few days we are going to dive a little deeper into some more areas of DevOps and then we will get into the sections that dive deeper into the tooling and processes and the benefits of these. Resources My advice is to watch all of the videos below and take notes on your own textbook or agenda. Going forward, try to keep pen and paper on your side, it will help you whenever you want to go back to your notes in the near future! What is DevOps? - TechWorld with Nana What is DevOps? - GitHub YouTube What is DevOps? - IBM YouTube What is DevOps? - AWS What is DevOps? - Microsoft See you in the Next Section .","title":"1. Responsibilities of a DevOps Engineer"},{"location":"Weeks/01/day01-01/#responsibilities-of-a-devops-engineer","text":"It was briefly touched on in the first post but now we must get deeper into this concept and understand that there are two main parts when creating an application. We have the Development part where software developers program the application and test it. Then we have the Operations part where the application is deployed and maintained on a server.","title":"Responsibilities of a DevOps Engineer"},{"location":"Weeks/01/day01-01/#devops-is-the-link-between-the-two","text":"To get to grips with DevOps or the tasks in which a DevOps engineer would be carrying out we need to understand the tools or the process and overview of those and how they come together. Everything starts with the application! You will see so much throughout that it is all about the application when it comes to DevOps. Developers will create an application, this can be done with many different technology stacks and lets leave that to the imagination for now as we get into this later. This can also involve many different programming languages, build tools, code repository etc. As a DevOps engineer you won't be programming the application but having a good understanding of the concepts of how a developer works and the systems, tools and processes they are using is key to success. At a very high level you are going to need to know how the application is configured to talk to all of its required services or data services and then also sprinkle a requirement of how this can or should be tested. The application will need to be deployed somewhere, lets keep it generally simple here and make this a server, doesn't matter where but a server. This is then expected to be accessed by the customer or end user depending on the application that has been created. This server needs to run somewhere, on-premises, in a public cloud, serverless. Someone needs to create and configure these servers and get them ready for the application to run. Now this element might land to you as a DevOps engineer to deploy and configure these servers. These servers will have to run an Operating System and generally speaking this is going to be Linux but we have a whole section or week where we cover some of the foundational knowledge you should gain here. It is also likely that we need to communicate with other services in our network or environment, so we also need to have that level of knowledge around networking and configuring that, this might to some degree also land at the feet of the DevOps engineer. Again we will cover this in more detail in a dedicated section talking all things DNS, DHCP, Load Balancing etc.","title":"DevOps is the link between the two"},{"location":"Weeks/01/day01-01/#jack-of-all-trades-master-of-none","text":"I will say at this point though, you don't need to be a Network or Infrastructure specialist you need a foundational knowledge of how to get things up and running and talking to each other, much the same as maybe having a foundational knowledge of a programming language but you don't need to be a developer. However you might be coming into this as a specialist in an area and that is a great footing to adapt to other areas. You will also most likely not take over the management of these servers or the application on a daily basis. We have been talking about servers but the likelihood is that your application will be developed to run as containers, Which still runs on a server for the most part but you will also need an understanding of not only virtualisation, Cloud Infrastructure as a Service (IaaS) but also containerization as well, this program will be focused and be catered towards containers.","title":"Jack of all trades, Master of none"},{"location":"Weeks/01/day01-01/#high-level-overview","text":"On one side we have our developers creating new features and functionality (as well as bug fixes) for the application. On the other side we have some sort of environment, infrastructure or servers which are configured and managed to run this application and communicate with all its required services. The big question is how do we get those features and bug fixes into our production and make it available to those end users? How do we release the new application version? This is one of the main tasks for a DevOps engineer, and the important thing here is not to just figure out how to do this once but we need to do this continuously and in an automated, efficient way which also needs to include testing! This is where we are going to end this day of learning, hopefully this was useful. Over the next few days we are going to dive a little deeper into some more areas of DevOps and then we will get into the sections that dive deeper into the tooling and processes and the benefits of these.","title":"High Level Overview"},{"location":"Weeks/01/day01-01/#resources","text":"My advice is to watch all of the videos below and take notes on your own textbook or agenda. Going forward, try to keep pen and paper on your side, it will help you whenever you want to go back to your notes in the near future! What is DevOps? - TechWorld with Nana What is DevOps? - GitHub YouTube What is DevOps? - IBM YouTube What is DevOps? - AWS What is DevOps? - Microsoft See you in the Next Section .","title":"Resources"},{"location":"Weeks/01/day01-02/","text":"DevOps Lifecycle - Application Focused As we continue through these next few weeks we are 100% going to come across these titles (Continuous Development, Testing, Deployment, Monitor) over and over again, If you are heading towards the DevOps Engineer role then repeatability will be something you will get used to but constantly enhancing each time is another thing that keeps things interesting. In this hour we are going to take a look at the high level view of the application from start to finish and then back round again like a constant loop. Development Let's take a brand new example of an Application, to start with we have nothing created, maybe as a developer you have to discuss with your client or end user on the requirements and come up with some sort of plan or requirements for your Application. We then need to create from the requirements our brand new application. In regards to tooling at this stage there is no real requirement here other than choosing your IDE and the programming language you wish to use to write your application. As a DevOps engineer, remember you are probably not the one creating this plan or coding the application for the end user, this will be a skilled developer. But it also would not hurt for you to be able to read some of the code so that you can make the best infrastructure decisions moving forward for your application. We previously mentioned that this application can be written in any language. Importantly this should be maintained using a version control system, this is something we will cover also in detail later on and in particular we will dive into Git . It is also likely that it will not be one developer working on this project although this could be the case but even so best practices would require a code repository to store and collaborate on the code, this could be private or public and could be hosted or privately deployed generally speaking you would hear the likes of GitHub or GitLab being used as a code repository. Again we will cover these as part of our section on Git later on. Testing At this stage we have our requirements and we have our application being developed. But we need to make sure we are testing our code in all the various different environments that we have available to us or specifically maybe to the programming language chosen. This phase enables QA to test for bugs, more frequently we see containers being used for simulating the test environment which overall can improve on cost overheads of physical or cloud infrastructure. This phase is also likely going to be automated as part of the next area which is Continuous Integration. The ability to automate this testing vs 10s,100s or even 1000s of QA engineers having to do this manually speaks for itself, these engineers can focus on something else within the stack to ensure you are moving faster and developing more functionality vs testing bugs and software which tends to be the hold up on most traditional software releases that use a waterfall methodology. Integration Quite importantly Integration is at the middle of the DevOps lifecycle. It is the practice of in which developers require to commit changes to the source code more frequently. This could be on a daily or weekly basis. With every commit your application can go through the automated testing phases and this allows for early detection of issues or bugs before the next phase. Now you might at this stage be saying \"but we don't create applications, we buy it off the shelf from a software vendor\" Don't worry many companies do this and will continue to do this and it will be the software vendor that is concentrating on the above 3 phases but you might want to still adopt the final phase as this will enable for faster and more efficient deployments of your off the shelf deployments. I would also suggest just having this above knowledge is very important as you might buy off the shelf software today, but what about tomorrow or down the line... next job maybe? Deployment Ok so we have our application built and tested against the requirements of our end user and we now need to go ahead and deploy this application into production for our end users to consume. This is the stage where the code is deployed to the production servers, now this is where things get extremely interesting and it is where the rest of our 86 days dives deeper into these areas. Because different applications require different possibly hardware or configurations. This is where Application Configuration Management and Infrastructure as Code could play a key part in your DevOps lifecycle. It might be that your application is Containerised but also available to run on a virtual machine. Which then also leads us onto platforms like Kubernetes which would be orchestrating those containers and making sure you have the desired state available to your end users. All of these bold topics we will go into more detail over the next few weeks to get a better foundational knowledge of what they are and when to use them. Monitoring Things are moving fast here and we have our Application that we are continuously updating with new features and functionality and we have our testing making sure no gremlins are being found. We have the application running in our environment that can be continually keeping the required configuration and performance. But now we need to be sure that our end users are getting the experience they require. Here we need to make sure that our Application Performance is continuously being monitored, this phase is going to allow your developers to make better decisions about enhancements to the application in future releases to better serve the end users. This section is also where we are going to capture that feedback wheel about the features that have been implemented and how the end users would like to make these better for them. Reliability is a key factor here as well, at the end of the day we want our Application to be available all the time it is required. This then lends to other observability, security and data management areas that should be continuously monitored and feedback can always be used to better enhance, update and release the application continuously. Some input from the community here specifically @_ediri mentioned also part of this continous process we should also have the FinOps teams involved. Apps & Data are running and stored somewhere you should be monitoring this continously to make sure if things change from a resources point of view your costs are not causing some major financial pain on your Cloud Bills. I think it is also a good time to bring up the \"DevOps Engineer\" mentions above, albeit there are many DevOps Engineer positions in the wild that people hold, this is not really the ideal way of positioning the process of DevOps. What I mean is from speaking to others in the community the title of DevOps Engineer should not be the goal for anyone because really any position should be adopting DevOps processes and the culture explained here. DevOps should be used in many different positions such as Cloud-Native engineer/architect, virtualisation admin, cloud architect/engineer, infrastructure admin. This is to name a few but the reason for using DevOps Engineer above was really to highlight the scope or the process used by any of the above positions and more. Resources My advice is to watch all of the videos below and take notes on your own textbook or agenda. Going forward, try to keep pen and paper on your side, it will help you whenever you want to go back to your notes in the near future! CI/CD Explained in 100 Seconds - FireShip YouTube Continuous Development I will also add that this is focused on manufacturing but the lean culture can be closely followed with DevOps. Continuous Testing - IBM YouTube Continuous Integration - IBM YouTube Continuous Monitoring The Remote Flow Que es CI/CD - PeladoNerd See you in the Next Section .","title":"2. Application Focused"},{"location":"Weeks/01/day01-02/#devops-lifecycle-application-focused","text":"As we continue through these next few weeks we are 100% going to come across these titles (Continuous Development, Testing, Deployment, Monitor) over and over again, If you are heading towards the DevOps Engineer role then repeatability will be something you will get used to but constantly enhancing each time is another thing that keeps things interesting. In this hour we are going to take a look at the high level view of the application from start to finish and then back round again like a constant loop.","title":"DevOps Lifecycle - Application Focused"},{"location":"Weeks/01/day01-02/#development","text":"Let's take a brand new example of an Application, to start with we have nothing created, maybe as a developer you have to discuss with your client or end user on the requirements and come up with some sort of plan or requirements for your Application. We then need to create from the requirements our brand new application. In regards to tooling at this stage there is no real requirement here other than choosing your IDE and the programming language you wish to use to write your application. As a DevOps engineer, remember you are probably not the one creating this plan or coding the application for the end user, this will be a skilled developer. But it also would not hurt for you to be able to read some of the code so that you can make the best infrastructure decisions moving forward for your application. We previously mentioned that this application can be written in any language. Importantly this should be maintained using a version control system, this is something we will cover also in detail later on and in particular we will dive into Git . It is also likely that it will not be one developer working on this project although this could be the case but even so best practices would require a code repository to store and collaborate on the code, this could be private or public and could be hosted or privately deployed generally speaking you would hear the likes of GitHub or GitLab being used as a code repository. Again we will cover these as part of our section on Git later on.","title":"Development"},{"location":"Weeks/01/day01-02/#testing","text":"At this stage we have our requirements and we have our application being developed. But we need to make sure we are testing our code in all the various different environments that we have available to us or specifically maybe to the programming language chosen. This phase enables QA to test for bugs, more frequently we see containers being used for simulating the test environment which overall can improve on cost overheads of physical or cloud infrastructure. This phase is also likely going to be automated as part of the next area which is Continuous Integration. The ability to automate this testing vs 10s,100s or even 1000s of QA engineers having to do this manually speaks for itself, these engineers can focus on something else within the stack to ensure you are moving faster and developing more functionality vs testing bugs and software which tends to be the hold up on most traditional software releases that use a waterfall methodology.","title":"Testing"},{"location":"Weeks/01/day01-02/#integration","text":"Quite importantly Integration is at the middle of the DevOps lifecycle. It is the practice of in which developers require to commit changes to the source code more frequently. This could be on a daily or weekly basis. With every commit your application can go through the automated testing phases and this allows for early detection of issues or bugs before the next phase. Now you might at this stage be saying \"but we don't create applications, we buy it off the shelf from a software vendor\" Don't worry many companies do this and will continue to do this and it will be the software vendor that is concentrating on the above 3 phases but you might want to still adopt the final phase as this will enable for faster and more efficient deployments of your off the shelf deployments. I would also suggest just having this above knowledge is very important as you might buy off the shelf software today, but what about tomorrow or down the line... next job maybe?","title":"Integration"},{"location":"Weeks/01/day01-02/#deployment","text":"Ok so we have our application built and tested against the requirements of our end user and we now need to go ahead and deploy this application into production for our end users to consume. This is the stage where the code is deployed to the production servers, now this is where things get extremely interesting and it is where the rest of our 86 days dives deeper into these areas. Because different applications require different possibly hardware or configurations. This is where Application Configuration Management and Infrastructure as Code could play a key part in your DevOps lifecycle. It might be that your application is Containerised but also available to run on a virtual machine. Which then also leads us onto platforms like Kubernetes which would be orchestrating those containers and making sure you have the desired state available to your end users. All of these bold topics we will go into more detail over the next few weeks to get a better foundational knowledge of what they are and when to use them.","title":"Deployment"},{"location":"Weeks/01/day01-02/#monitoring","text":"Things are moving fast here and we have our Application that we are continuously updating with new features and functionality and we have our testing making sure no gremlins are being found. We have the application running in our environment that can be continually keeping the required configuration and performance. But now we need to be sure that our end users are getting the experience they require. Here we need to make sure that our Application Performance is continuously being monitored, this phase is going to allow your developers to make better decisions about enhancements to the application in future releases to better serve the end users. This section is also where we are going to capture that feedback wheel about the features that have been implemented and how the end users would like to make these better for them. Reliability is a key factor here as well, at the end of the day we want our Application to be available all the time it is required. This then lends to other observability, security and data management areas that should be continuously monitored and feedback can always be used to better enhance, update and release the application continuously. Some input from the community here specifically @_ediri mentioned also part of this continous process we should also have the FinOps teams involved. Apps & Data are running and stored somewhere you should be monitoring this continously to make sure if things change from a resources point of view your costs are not causing some major financial pain on your Cloud Bills. I think it is also a good time to bring up the \"DevOps Engineer\" mentions above, albeit there are many DevOps Engineer positions in the wild that people hold, this is not really the ideal way of positioning the process of DevOps. What I mean is from speaking to others in the community the title of DevOps Engineer should not be the goal for anyone because really any position should be adopting DevOps processes and the culture explained here. DevOps should be used in many different positions such as Cloud-Native engineer/architect, virtualisation admin, cloud architect/engineer, infrastructure admin. This is to name a few but the reason for using DevOps Engineer above was really to highlight the scope or the process used by any of the above positions and more.","title":"Monitoring"},{"location":"Weeks/01/day01-02/#resources","text":"My advice is to watch all of the videos below and take notes on your own textbook or agenda. Going forward, try to keep pen and paper on your side, it will help you whenever you want to go back to your notes in the near future! CI/CD Explained in 100 Seconds - FireShip YouTube Continuous Development I will also add that this is focused on manufacturing but the lean culture can be closely followed with DevOps. Continuous Testing - IBM YouTube Continuous Integration - IBM YouTube Continuous Monitoring The Remote Flow Que es CI/CD - PeladoNerd See you in the Next Section .","title":"Resources"},{"location":"Weeks/01/day01-03/","text":"DevOps & Agile Do you know the difference between DevOps and Agile ? They were formed as standalone concepts. But now the two terms are getting fused. In this post we will examine the crucial differences between agile and DevOps and find out why the two are connected so tightly. I think a good place to start is understanding a little more about a common angle I have seen in learning this area and that is DevOps vs Agile, even though they have similar goals and processes. In this section, I am going to summarise this hopefully. Let's start with definitions. Agile Development Agile is an approach that focuses on delivering small results faster rather than releasing one big interaction of the product, software is developed in iterations. The team releases a new version every week or month with non-incremental updates the final goal of agile is to deliver an optimal experience to the end-users DevOps We have been covering this for the past few days with a few different ways of describing the end goals of DevOps, DevOps usually describes software development and delivery practices based on cooperation between software developers and operations specialists the main DevOps benefits are delivering a simplified development process and minimising miscommunication. What is the difference between Agile and DevOps The difference is mainly the preoccupations. Agile and devops have different preoccupations but they are helping each other. Agile want short iteration, which is only possible with the automation that Devops brings. Agile want customer to try a specific version and quickly give feedback which is only possible if devops make creation of new environment easy. Different participants Agile focuses on optimising communication between end-users and developers while DevOps targets developers and operation team members. We could say that agile is outward-oriented towards customers whereas DevOps is a set of internal practices. Team Agile usually applies to software developers and project managers. The competencies of DevOps engineers lie in the intersection of development, QA and operations they are involved in all stages of the product cycle and they are part of the Agile team. Applied Frameworks Agile has a lot of management frameworks to achieve flexibility and transparency. Scrum > Kanban > Lean > Extreme > Crystal > Dynamic > Feature-Driven >. DevOps focuses on the development approach in collaboration but doesn't offer specific methodologies. However devops promote practices like Infrastructure as Code, Architecture as Code, Monitoring, Self Healing, end to end test automation ... But per say this is not framework, rather practices. Feedback In Agile the main source of feedback is the end user in DevOps the feedback from stakeholders and the team itself has a higher priority. Target areas Agile focuses on software development more than on deployment and maintenance. DevOps focuses on software development as well but its values and tools also cover deployment and post-release stages like monitoring, high availibility, security and data protection. Documentation Agile prioritises flexibility and tasks at hand over documentation and monitor. DevOps on the other hand regards project documentation as one of the essential project components. Risks Agile risks derive from the flexibility of the methodology. Agile projects are difficult to predict or evaluate as priorities and requirements are continually changing. DevOps risks derive from a misunderstanding of the term and the lack of suitable tools. Some people see DevOps as a collection of software for the deployment and continuous integration failing to change the underlying structure of the development process The Tools Used Agile tools are focused on management communication collaboration, metrics and feedback processing. The most popular agile tools include JIRA, Trello, Slack, zoom SurveyMonkey and others. DevOps uses tools for team communication, software development, deployment and integration like Jenkins, GitHub Actions, BitBucket, even though agile and DevOps have slightly different focuses and scopes the key values are almost identical therefore you can combine the two. Bring it all together\u2026 good idea or not? Discuss? The combination of Agile and DevOps brings the following benefits you get - Flexible management and powerful technology - Agile practices help DevOps teams to communicate their priorities more efficiently - The automation cost that you have to pay for your devops practices are justified by your agile requirement of deploying quickly and frequently - It leads to strengthening the team adopting agile practices will improve collaboration increase the team's motivation and decrease employee turnover rates - As a result, you get better product quality Agile allows coming back to previous product development stages to fix errors and prevent the accumulation of technical debt. To adopt agile and DevOps simultaneously just follow 7 steps : Unite the development and operation teams. Create build and run teams, all development and operational concerns are discussed by the entire DevOps team. Change your approach to sprints, assign priority ratings to offer devops tasks that has the same value than development task. Encourage development and operations teams to exchange their opinion on other teams workflow and possible issues. Include QA in all development stages. Choose the right tools. Automate everything you can. Measure and control by using tangible numeric deliverables. What do you think? Do you have different views? I want to hear from you, send me a message on Slack and send me your comments. Resources My advice is to watch all of the videos below and take notes on your own textbook or agenda. Going forward, try to keep pen and paper on your side, it will help you whenever you want to go back to your notes in the near future! DevOps for Developers \u2013 Day in the Life: DevOps Engineer in 2021 3 Things I wish I knew as a DevOps Engineer How to become a DEVOPS Engineer feat. Shawn Powers See you in the Next Section .","title":"3. DevOps & Agile"},{"location":"Weeks/01/day01-03/#devops-agile","text":"Do you know the difference between DevOps and Agile ? They were formed as standalone concepts. But now the two terms are getting fused. In this post we will examine the crucial differences between agile and DevOps and find out why the two are connected so tightly. I think a good place to start is understanding a little more about a common angle I have seen in learning this area and that is DevOps vs Agile, even though they have similar goals and processes. In this section, I am going to summarise this hopefully. Let's start with definitions.","title":"DevOps &amp; Agile"},{"location":"Weeks/01/day01-03/#agile-development","text":"Agile is an approach that focuses on delivering small results faster rather than releasing one big interaction of the product, software is developed in iterations. The team releases a new version every week or month with non-incremental updates the final goal of agile is to deliver an optimal experience to the end-users","title":"Agile Development"},{"location":"Weeks/01/day01-03/#devops","text":"We have been covering this for the past few days with a few different ways of describing the end goals of DevOps, DevOps usually describes software development and delivery practices based on cooperation between software developers and operations specialists the main DevOps benefits are delivering a simplified development process and minimising miscommunication.","title":"DevOps"},{"location":"Weeks/01/day01-03/#what-is-the-difference-between-agile-and-devops","text":"The difference is mainly the preoccupations. Agile and devops have different preoccupations but they are helping each other. Agile want short iteration, which is only possible with the automation that Devops brings. Agile want customer to try a specific version and quickly give feedback which is only possible if devops make creation of new environment easy.","title":"What is the difference between Agile and DevOps"},{"location":"Weeks/01/day01-03/#different-participants","text":"Agile focuses on optimising communication between end-users and developers while DevOps targets developers and operation team members. We could say that agile is outward-oriented towards customers whereas DevOps is a set of internal practices.","title":"Different participants"},{"location":"Weeks/01/day01-03/#team","text":"Agile usually applies to software developers and project managers. The competencies of DevOps engineers lie in the intersection of development, QA and operations they are involved in all stages of the product cycle and they are part of the Agile team.","title":"Team"},{"location":"Weeks/01/day01-03/#applied-frameworks","text":"Agile has a lot of management frameworks to achieve flexibility and transparency. Scrum > Kanban > Lean > Extreme > Crystal > Dynamic > Feature-Driven >. DevOps focuses on the development approach in collaboration but doesn't offer specific methodologies. However devops promote practices like Infrastructure as Code, Architecture as Code, Monitoring, Self Healing, end to end test automation ... But per say this is not framework, rather practices.","title":"Applied Frameworks"},{"location":"Weeks/01/day01-03/#feedback","text":"In Agile the main source of feedback is the end user in DevOps the feedback from stakeholders and the team itself has a higher priority.","title":"Feedback"},{"location":"Weeks/01/day01-03/#target-areas","text":"Agile focuses on software development more than on deployment and maintenance. DevOps focuses on software development as well but its values and tools also cover deployment and post-release stages like monitoring, high availibility, security and data protection.","title":"Target areas"},{"location":"Weeks/01/day01-03/#documentation","text":"Agile prioritises flexibility and tasks at hand over documentation and monitor. DevOps on the other hand regards project documentation as one of the essential project components.","title":"Documentation"},{"location":"Weeks/01/day01-03/#risks","text":"Agile risks derive from the flexibility of the methodology. Agile projects are difficult to predict or evaluate as priorities and requirements are continually changing. DevOps risks derive from a misunderstanding of the term and the lack of suitable tools. Some people see DevOps as a collection of software for the deployment and continuous integration failing to change the underlying structure of the development process","title":"Risks"},{"location":"Weeks/01/day01-03/#the-tools-used","text":"Agile tools are focused on management communication collaboration, metrics and feedback processing. The most popular agile tools include JIRA, Trello, Slack, zoom SurveyMonkey and others. DevOps uses tools for team communication, software development, deployment and integration like Jenkins, GitHub Actions, BitBucket, even though agile and DevOps have slightly different focuses and scopes the key values are almost identical therefore you can combine the two.","title":"The Tools Used"},{"location":"Weeks/01/day01-03/#bring-it-all-together-good-idea-or-not-discuss","text":"The combination of Agile and DevOps brings the following benefits you get - Flexible management and powerful technology - Agile practices help DevOps teams to communicate their priorities more efficiently - The automation cost that you have to pay for your devops practices are justified by your agile requirement of deploying quickly and frequently - It leads to strengthening the team adopting agile practices will improve collaboration increase the team's motivation and decrease employee turnover rates - As a result, you get better product quality Agile allows coming back to previous product development stages to fix errors and prevent the accumulation of technical debt. To adopt agile and DevOps simultaneously just follow 7 steps : Unite the development and operation teams. Create build and run teams, all development and operational concerns are discussed by the entire DevOps team. Change your approach to sprints, assign priority ratings to offer devops tasks that has the same value than development task. Encourage development and operations teams to exchange their opinion on other teams workflow and possible issues. Include QA in all development stages. Choose the right tools. Automate everything you can. Measure and control by using tangible numeric deliverables. What do you think? Do you have different views? I want to hear from you, send me a message on Slack and send me your comments.","title":"Bring it all together\u2026 good idea or not? Discuss?"},{"location":"Weeks/01/day01-03/#resources","text":"My advice is to watch all of the videos below and take notes on your own textbook or agenda. Going forward, try to keep pen and paper on your side, it will help you whenever you want to go back to your notes in the near future! DevOps for Developers \u2013 Day in the Life: DevOps Engineer in 2021 3 Things I wish I knew as a DevOps Engineer How to become a DEVOPS Engineer feat. Shawn Powers See you in the Next Section .","title":"Resources"},{"location":"Weeks/01/day01-04/","text":"Plan > Code > Build > Testing > Release > Deploy > Operate > Monitor > Today we are going to focus on the individual steps from start to finish and the continous cycle of an Application in a DevOps world. Plan: It all starts with the planning process this is where the development team gets together and figure out what types of features and bug fixes that they're going to roll out in their next sprint. This is an opportunity as a DevOps Engineer for you to get involved with that and learn what kinds of things are going to be coming your way that you need to be involved with and also influence their decisions or their path and kind of help them work with the infrastructure that you've built or steer them towards something that's going to work better for them in case they're not on that path and so one key thing to point out here is the developers or software engineering team is your customer as a DevOps engineer so this is your opportunity to work with your customer before they go down a bad path. Code: Now once that planning session's done they're going to go start writing the code you may or may not be involved a whole lot with this one of the places you may get involved with it, is whenever they're writing code you can help them better understand the infrastructure so if they know what services are available and how to best talk with those services so they're going to do that and then once they're done they'll merge that code into the repository Build: This is where we'll kick off the first of our automation processes because we're going to take their code and we're going to build it depending on what language they're using it may be transpiling it or compiling it or it might be creating a docker image from that code either way we're going to go through that process using our ci cd pipeline Testing: Once we've built it we're going to run some tests on it now the development team usually writes the test you may have some input in what tests get written but we need to run those tests and the testing is a way for us to try and minimise introducing problems out into production, it doesn't guarantee that but we want to get as close to a guarantee as we can that were one not introducing new bugs and two not breaking things that used to work Release: Once those tests pass we're going to do the release process and depending again on what type of application you're working on this may be a non-step. You know the code may just live in the GitHub repo or the git repository or wherever it lives but it may be the process of taking your compiled code or the docker image that you've built and putting it into a registry or a repository where it's accessible by your production servers for the deployment process Deploy: which is the thing that we do next because deployment is like the end game of this whole thing because deployments when we put the code into production and it's not until we do that that our business actually realizes the value from all the time effort and hard work that you and the software engineering team have put into this product up to this point. Operate: Once it's deployed we are going to operate it and operate it may involve something like you start getting calls from your customers that they're all annoyed that the site's running slow or their application is running slow right so you need to figure out why that is and then possibly build auto-scaling you know to handle increase the number of servers available during peak periods and decrease the number of servers during off-peak periods either way that's all operational type metrics, another operational thing that you do is include like a feedback loop from production back to your ops team letting you know about key events that happened in production such as a deployment back one step on the deployment thing this may or may not get automated depending on your environment the goal is to always automate it when possible there are some environments where you possibly need to do a few steps before you're ready to do that but ideally you want to deploy automatically as part of your automation process but if you're doing that it might be a good idea to include in your operational steps some type of notification so that your ops team knows that a deployment has happened Monitor: All of the above parts lead to the final step because you need to have monitoring, especially around operational issues auto-scaling troubleshooting like you don't know there's a problem if you don't have monitoring in place to tell you that there's a problem so some of the things you might build monitoring for are memory utilization CPU utilization disk space, api endpoint, response time, how quickly that endpoint is responding and a big part of that as well is logs. Logs give developers the ability to see what is happening without having to access production systems. Rince & Repeat: Once that's in place you go right back to the beginning to the planning stage and go through the whole thing again Continuous: Many tools help us achieve the above continuous process, all this code and the ultimate goal of being completely automated, cloud infrastructure or any environment is often described as Continuous Integration/ Continuous Delivery/Continous Deployment or \u201cCI/CD\u201d for short. We will spend a whole week on CI/CD later on in the 90 Days with some examples and walkthroughs to grasp the fundamentals. Continuous Delivery: Continuous Delivery = Plan > Code > Build > Test Continuous Integration: This is effectively the outcome of the Continuous Delivery phases above plus the outcome of the Release phase. This is the case for both failure and success but this is fed back into continuous delivery or moved to Continuous Deployment. Continuous Integration = Plan > Code > Build > Test > Release Continuous Deployment: If you have a successful release from your continuous integration then move to Continuous Deployment which brings in the following phases CI Release is Success = Continuous Deployment = Deploy > Operate > Monitor You can see these three Continuous notions above as the simple collection of phases of the DevOps Lifecycle. This last bit was a bit of a recap for me on Day 3 but think this actually makes things clearer for me. Resources: My advice is to watch all of the videos below and take notes on your own textbook or agenda. Going forward, try to keep pen and paper on your side, it will help you whenever you want to go back to your notes in the near future! DevOps for Developers \u2013 Software or DevOps Engineer? Techworld with Nana -DevOps Roadmap 2022 - How to become a DevOps Engineer? What is DevOps? How to become a DevOps Engineer in 2021 - DevOps Roadmap See you in the Next Section .","title":"4. DevOps Cycle"},{"location":"Weeks/01/day01-04/#plan-code-build-testing-release-deploy-operate-monitor","text":"Today we are going to focus on the individual steps from start to finish and the continous cycle of an Application in a DevOps world.","title":"Plan &gt; Code &gt; Build &gt; Testing &gt; Release &gt; Deploy &gt; Operate &gt; Monitor &gt;"},{"location":"Weeks/01/day01-04/#plan","text":"It all starts with the planning process this is where the development team gets together and figure out what types of features and bug fixes that they're going to roll out in their next sprint. This is an opportunity as a DevOps Engineer for you to get involved with that and learn what kinds of things are going to be coming your way that you need to be involved with and also influence their decisions or their path and kind of help them work with the infrastructure that you've built or steer them towards something that's going to work better for them in case they're not on that path and so one key thing to point out here is the developers or software engineering team is your customer as a DevOps engineer so this is your opportunity to work with your customer before they go down a bad path.","title":"Plan:"},{"location":"Weeks/01/day01-04/#code","text":"Now once that planning session's done they're going to go start writing the code you may or may not be involved a whole lot with this one of the places you may get involved with it, is whenever they're writing code you can help them better understand the infrastructure so if they know what services are available and how to best talk with those services so they're going to do that and then once they're done they'll merge that code into the repository","title":"Code:"},{"location":"Weeks/01/day01-04/#build","text":"This is where we'll kick off the first of our automation processes because we're going to take their code and we're going to build it depending on what language they're using it may be transpiling it or compiling it or it might be creating a docker image from that code either way we're going to go through that process using our ci cd pipeline","title":"Build:"},{"location":"Weeks/01/day01-04/#testing","text":"Once we've built it we're going to run some tests on it now the development team usually writes the test you may have some input in what tests get written but we need to run those tests and the testing is a way for us to try and minimise introducing problems out into production, it doesn't guarantee that but we want to get as close to a guarantee as we can that were one not introducing new bugs and two not breaking things that used to work","title":"Testing:"},{"location":"Weeks/01/day01-04/#release","text":"Once those tests pass we're going to do the release process and depending again on what type of application you're working on this may be a non-step. You know the code may just live in the GitHub repo or the git repository or wherever it lives but it may be the process of taking your compiled code or the docker image that you've built and putting it into a registry or a repository where it's accessible by your production servers for the deployment process","title":"Release:"},{"location":"Weeks/01/day01-04/#deploy","text":"which is the thing that we do next because deployment is like the end game of this whole thing because deployments when we put the code into production and it's not until we do that that our business actually realizes the value from all the time effort and hard work that you and the software engineering team have put into this product up to this point.","title":"Deploy:"},{"location":"Weeks/01/day01-04/#operate","text":"Once it's deployed we are going to operate it and operate it may involve something like you start getting calls from your customers that they're all annoyed that the site's running slow or their application is running slow right so you need to figure out why that is and then possibly build auto-scaling you know to handle increase the number of servers available during peak periods and decrease the number of servers during off-peak periods either way that's all operational type metrics, another operational thing that you do is include like a feedback loop from production back to your ops team letting you know about key events that happened in production such as a deployment back one step on the deployment thing this may or may not get automated depending on your environment the goal is to always automate it when possible there are some environments where you possibly need to do a few steps before you're ready to do that but ideally you want to deploy automatically as part of your automation process but if you're doing that it might be a good idea to include in your operational steps some type of notification so that your ops team knows that a deployment has happened","title":"Operate:"},{"location":"Weeks/01/day01-04/#monitor","text":"All of the above parts lead to the final step because you need to have monitoring, especially around operational issues auto-scaling troubleshooting like you don't know there's a problem if you don't have monitoring in place to tell you that there's a problem so some of the things you might build monitoring for are memory utilization CPU utilization disk space, api endpoint, response time, how quickly that endpoint is responding and a big part of that as well is logs. Logs give developers the ability to see what is happening without having to access production systems.","title":"Monitor:"},{"location":"Weeks/01/day01-04/#rince-repeat","text":"Once that's in place you go right back to the beginning to the planning stage and go through the whole thing again","title":"Rince &amp; Repeat:"},{"location":"Weeks/01/day01-04/#continuous","text":"Many tools help us achieve the above continuous process, all this code and the ultimate goal of being completely automated, cloud infrastructure or any environment is often described as Continuous Integration/ Continuous Delivery/Continous Deployment or \u201cCI/CD\u201d for short. We will spend a whole week on CI/CD later on in the 90 Days with some examples and walkthroughs to grasp the fundamentals.","title":"Continuous:"},{"location":"Weeks/01/day01-04/#continuous-delivery","text":"Continuous Delivery = Plan > Code > Build > Test","title":"Continuous Delivery:"},{"location":"Weeks/01/day01-04/#continuous-integration","text":"This is effectively the outcome of the Continuous Delivery phases above plus the outcome of the Release phase. This is the case for both failure and success but this is fed back into continuous delivery or moved to Continuous Deployment. Continuous Integration = Plan > Code > Build > Test > Release","title":"Continuous Integration:"},{"location":"Weeks/01/day01-04/#continuous-deployment","text":"If you have a successful release from your continuous integration then move to Continuous Deployment which brings in the following phases CI Release is Success = Continuous Deployment = Deploy > Operate > Monitor You can see these three Continuous notions above as the simple collection of phases of the DevOps Lifecycle. This last bit was a bit of a recap for me on Day 3 but think this actually makes things clearer for me.","title":"Continuous Deployment:"},{"location":"Weeks/01/day01-04/#resources","text":"My advice is to watch all of the videos below and take notes on your own textbook or agenda. Going forward, try to keep pen and paper on your side, it will help you whenever you want to go back to your notes in the near future! DevOps for Developers \u2013 Software or DevOps Engineer? Techworld with Nana -DevOps Roadmap 2022 - How to become a DevOps Engineer? What is DevOps? How to become a DevOps Engineer in 2021 - DevOps Roadmap See you in the Next Section .","title":"Resources:"},{"location":"Weeks/01/day01-05/","text":"DevOps - The real stories DevOps to begin with was seen to be out of reach for a lot of us as we didn't have an environment or requirement anything like a Netflix or fortune 500 but think now that is beginning to sway into the normal when adopting a DevOps practice within any type of business. You will see from the second link below in references there are a lot of different industries and verticals using DevOps and having a hugely positive effect on their business objectives. Obviously the overarching benefit here is DevOps if done correctly should help your Business improve the speed and quality of software development. I wanted to take this section to look at succesful companies that have adopted a DevOps practice and share some resources around this. I mentioned Netflix above and will touch on them again as it is a very good model and advanced to what we generally see today even still but will also mention some other big name brands that are succeeding it seems. Amazon In 2010 Amazon moved their physical server footprint to Amazon Web Services (AWS) cloud this allowed them to save resources by scaling capacity up and down in very small increments. We also know that this AWS cloud would go on and make a huge amount of revenue itself whilst still running the Amazon retail branch of the company. Amazon adopted in 2011 (According to the resource below) a continued deployment process where their developers could deploy code whenever they want and to whatever servers they needed. This enabled Amazon to achieve deploying new software to production servers on average every 11.6 seconds! Netflix Who doesn't use Netflix? obviously a huge quality streaming service with by all accounts at least personally a great user experience. Why is that user experience so great? Well the ability to deliver a service with no recollected memory for me at least of glitches requires speed, flexibility, and attention to quality. NetFlix developers can automatically build pieces of code into deployable web images without relying on IT operations. As the images are updated, they are integrated into Netflix\u2019s infrastructure using a custom-built, web-based platform. Continous Monitoring is in place so that if the deployment of the images fails, the new images are rolled back and traffic rerouted to the previous version. There is a great talk listed below that goes into more about the DOs and DONTs that Netflix live and die by within their teams. Etsy As with many of us and many companies there was a real struggle around slow and painful deployments. In the same vein we might have also experienced working in companies that have lots of siloes and teams that are not really working well together. From what I can make out at least from reading about Amazon and Netflix, Etsy might have adopted the letting developers deploy their own code around the end of 2009 which might have been before the other two mentioned. (interesting!) An interesting take away I read here was that they realised that when developers feel responsibility for deployment they also would take responsibility for application performance, uptime and other goals. A learning culture is a key part to DevOps, even failure can be a success if lessons are learned. (not sure where this quote actually came from but it kind of makes sense!) I have added some other stories where DevOps has changed the game within some of these massively successful companies. Resources My advice is to watch all of the videos below and take notes on your own textbook or agenda. Going forward, try to keep pen and paper on your side, it will help you whenever you want to go back to your notes in the near future! How Netflix Thinks of DevOps 16 Popular DevOps Use Cases & Real Life Applications [2021] DevOps: The Amazon Story How Etsy makes DevOps work Adopting DevOps @ Scale Lessons learned at Hertz, Kaiser Permanente and lBM Interplanetary DevOps at NASA JPL Target CIO explains how DevOps took root inside the retail giant Recap of our first week looking at DevOps DevOps is a combo of Development and Operations that allows a single team to manage the whole application development lifecycle that consists of Development , Testing , Deployment , Operations . The main focus and aim of DevOps is to shorten the development lifecycle while delivering features, fixes and functionality frequently in close alignment with business objectives. DevOps is a software development approach through which software can be delivered and developed reliably and quickly. You may also see this referenced as Continuous Development, Testing, Deployment, Monitoring See you in Next Section . Next we will dive into a programming language. We are not aiming to be a web developer per say but we want to be able to understand what the developers are doing.","title":"5. The real stories"},{"location":"Weeks/01/day01-05/#devops-the-real-stories","text":"DevOps to begin with was seen to be out of reach for a lot of us as we didn't have an environment or requirement anything like a Netflix or fortune 500 but think now that is beginning to sway into the normal when adopting a DevOps practice within any type of business. You will see from the second link below in references there are a lot of different industries and verticals using DevOps and having a hugely positive effect on their business objectives. Obviously the overarching benefit here is DevOps if done correctly should help your Business improve the speed and quality of software development. I wanted to take this section to look at succesful companies that have adopted a DevOps practice and share some resources around this. I mentioned Netflix above and will touch on them again as it is a very good model and advanced to what we generally see today even still but will also mention some other big name brands that are succeeding it seems.","title":"DevOps - The real stories"},{"location":"Weeks/01/day01-05/#amazon","text":"In 2010 Amazon moved their physical server footprint to Amazon Web Services (AWS) cloud this allowed them to save resources by scaling capacity up and down in very small increments. We also know that this AWS cloud would go on and make a huge amount of revenue itself whilst still running the Amazon retail branch of the company. Amazon adopted in 2011 (According to the resource below) a continued deployment process where their developers could deploy code whenever they want and to whatever servers they needed. This enabled Amazon to achieve deploying new software to production servers on average every 11.6 seconds!","title":"Amazon"},{"location":"Weeks/01/day01-05/#netflix","text":"Who doesn't use Netflix? obviously a huge quality streaming service with by all accounts at least personally a great user experience. Why is that user experience so great? Well the ability to deliver a service with no recollected memory for me at least of glitches requires speed, flexibility, and attention to quality. NetFlix developers can automatically build pieces of code into deployable web images without relying on IT operations. As the images are updated, they are integrated into Netflix\u2019s infrastructure using a custom-built, web-based platform. Continous Monitoring is in place so that if the deployment of the images fails, the new images are rolled back and traffic rerouted to the previous version. There is a great talk listed below that goes into more about the DOs and DONTs that Netflix live and die by within their teams.","title":"Netflix"},{"location":"Weeks/01/day01-05/#etsy","text":"As with many of us and many companies there was a real struggle around slow and painful deployments. In the same vein we might have also experienced working in companies that have lots of siloes and teams that are not really working well together. From what I can make out at least from reading about Amazon and Netflix, Etsy might have adopted the letting developers deploy their own code around the end of 2009 which might have been before the other two mentioned. (interesting!) An interesting take away I read here was that they realised that when developers feel responsibility for deployment they also would take responsibility for application performance, uptime and other goals. A learning culture is a key part to DevOps, even failure can be a success if lessons are learned. (not sure where this quote actually came from but it kind of makes sense!) I have added some other stories where DevOps has changed the game within some of these massively successful companies.","title":"Etsy"},{"location":"Weeks/01/day01-05/#resources","text":"My advice is to watch all of the videos below and take notes on your own textbook or agenda. Going forward, try to keep pen and paper on your side, it will help you whenever you want to go back to your notes in the near future! How Netflix Thinks of DevOps 16 Popular DevOps Use Cases & Real Life Applications [2021] DevOps: The Amazon Story How Etsy makes DevOps work Adopting DevOps @ Scale Lessons learned at Hertz, Kaiser Permanente and lBM Interplanetary DevOps at NASA JPL Target CIO explains how DevOps took root inside the retail giant","title":"Resources"},{"location":"Weeks/01/day01-05/#recap-of-our-first-week-looking-at-devops","text":"DevOps is a combo of Development and Operations that allows a single team to manage the whole application development lifecycle that consists of Development , Testing , Deployment , Operations . The main focus and aim of DevOps is to shorten the development lifecycle while delivering features, fixes and functionality frequently in close alignment with business objectives. DevOps is a software development approach through which software can be delivered and developed reliably and quickly. You may also see this referenced as Continuous Development, Testing, Deployment, Monitoring See you in Next Section . Next we will dive into a programming language. We are not aiming to be a web developer per say but we want to be able to understand what the developers are doing.","title":"Recap of our first week looking at DevOps"},{"location":"Weeks/01/day02-01/","text":"The Big Picture: DevOps & Learning a Programming Language It is important to highlight that to be successful in the long term as a DevOps engineer, you've got to know at least one programming language at a foundational level. We want to take this first session of this section to explore why this is such a critical skill to have, and hopefully, by the end of this week or section, you are going to have a better understanding of the why, how and what to do to progress with your learning journey. If we were to ask out on the wild if you need to have programming skills for DevOps related roles, the answer would probably be a resounding yes. However, the bigger question here that most of us ask ourselves is which programming language should I invest my time into? The most common answer in 2022 has been Python or increasingly more often, we're seeing Golang or Go as one of the best languages that you can learn for this role. To be successful in DevOps you have to have a good knowledge of programming skills but further than that, what is value in the role is the ability to solve problems as much as proposing architectural designs and solutions for scalable applications in the cloud. Understand why you need to learn a programming language. The reason that Python and Go are recommended so often for DevOps engineers is that a lot of the DevOps tooling is written in either Python or Go, which makes sense if you are going to be building, using and maintaing any type of DevOps tools. Now this is important as this will determine really what you should learn and that would likely be the most beneficial skillsets for this career path. Since in the future, we are going to be heavily involved in Kubernetes and Containers, then it's more than likely that choosing Go as your programming language would heavily increase productivity but Python will be as helpful for you. In our ecosystems, we are focusing on deploying EC2 instances on AWS and automating a lot of our tasks and deployments using Terraform so having knowledge on data management for Kubernetes will be beneficial as everything is written in Go. Remember we are not going to be building applications but the goal here is to understand a little more about the programming language so that we can read and understand what those tools are doing and then that can bring opportunities on how we can help on improving our tools. I would also it is also important to know how you interact with those DevOps tools which could be K8s or it could be Terraform and Ansible. These are what we will call config files and this is how you interact with those DevOps tools to make things happen, commonly these are going to be YAML. (We may use the last day of this section to dive a little into YAML) Did we just talk ourselves out of learning a programming language? Most of the time or depending on the role, you will be helping engineering teams implement DevOps into their workflow, a lot of testing around the application and making sure that the workflow that is built aligns to those DevOps principles we mentioned over the first few days. But in reality, this is going to be a lot of the time troubleshooting an application performance issue or something along those lines. This comes back to my original point and reasoning, the programming language I need to know is the one that the code is written in? If their application is written in NodeJS it won\u2019t help much if you have a Go or Python badge or certification. Why Go You may ask yourself why is Golangv considered as the next programming language for DevOps and you may find that most Go most definitely has become a very popular programming language in recent years. According to the StackOverflow Survey for 2021, Go came in fourth for the most wanted Programming, scripting and markup languages with Python being top. StackOverflow 2021 Developer Survey \u2013 Most Wanted Link However, as I have also mentioned some of the most known DevOps tools and platforms are written in Go such as Kubernetes, Docker, Grafana and Prometheus and having at least a base knowledge on Go will greatly elevate your understanding when working with those type of tools. What are some of the characteristics of Go that make it great for DevOps? Build and Deployment of Go Programs An advantage of using a language like Python that is interpreted in a DevOps role is that you don\u2019t need to compile a python program before running it. Especially for smaller automation tasks, you don\u2019t want to be slowed down by a build process that requires compilation even though, Go is a compiled programming language, Go compiles directly into machine code . Go is known also for fast compilation times. Go vs Python for DevOps Go Programs are statically linked, this means that when you compile a go program everything is included in a single binary executable, no external dependencies will be required that would need to be installed on the remote machine, this makes the deployment of go programs easy, compared to python program that uses external libraries you have to make sure that all those libraries are installed on the remote machine that you wish to run on. Go is a platform-independent language, which means you can produce binary executables for *all the operating systems, Linux, Windows, macOS etc and very easy to do so. With Python, it is not as easy to create these binary executables for particular operating systems. Go is a very performant language, it has fast compilation and fast run time with lower resource usage like CPU and memory especially compared to python, numerous optimizations have been implemented in the Go language that makes it so performant. (Resources below) Unlike Python which often requires the use of third party libraries to implement a particular python program, go includes a standard library that has the majority of functionality that you would need for DevOps built directly into it. This includes functionality file processing, HTTP web services, JSON processing, native support for concurrency and parallelism as well as built-in testing. This is by no way throwing Python under the bus as we will still be touching and seeing python further down the course, however the main reasoning here for choosing Go just right now is so that we can have a broader knowledge on how Go applications are constructed, however in the future you can easiy focus on Python if that's your cup of tea and that's completely valid. Just that for now, we will work with Go just to build general bases on it which will prove to be helpful whenever we work with devops tools that are programmed on this specific language. I will say that once you start fo fully master a programming language it becomes easier to take on other languages. You're probably never going to have a single job in any company anywhere where you don't have to deal with manage, architect, orchestrating, debug JavaScript and Node JS applications so being able to be versatile with our skills will definitely set us up for success. Resources StackOverflow 2021 Developer Survey Why we are choosing Golang to learn Jake Wright - Learn Go in 12 minutes Techworld with Nana - Golang full course - 3 hours 24 mins FreeCodeCamp - Learn Go Programming - Golang Tutorial for Beginners Hitesh Choudhary - Complete playlist Now for the next 6 days of this topic my intention is to work through some of the resources listed above and document your notes for each day. You will notice that they are generally around 3 hours as a full course, I wanted to share my complete list so that if you have time you should move ahead and work through each one if time permits. I am not expecting that we will learn a programming language from beginning to end within a week but will definitely be a great tool to start using on our workflows. See you in Next Section .","title":"1. The Big Picture: Learning a Programming Language"},{"location":"Weeks/01/day02-01/#the-big-picture-devops-learning-a-programming-language","text":"It is important to highlight that to be successful in the long term as a DevOps engineer, you've got to know at least one programming language at a foundational level. We want to take this first session of this section to explore why this is such a critical skill to have, and hopefully, by the end of this week or section, you are going to have a better understanding of the why, how and what to do to progress with your learning journey. If we were to ask out on the wild if you need to have programming skills for DevOps related roles, the answer would probably be a resounding yes. However, the bigger question here that most of us ask ourselves is which programming language should I invest my time into? The most common answer in 2022 has been Python or increasingly more often, we're seeing Golang or Go as one of the best languages that you can learn for this role. To be successful in DevOps you have to have a good knowledge of programming skills but further than that, what is value in the role is the ability to solve problems as much as proposing architectural designs and solutions for scalable applications in the cloud.","title":"The Big Picture: DevOps &amp; Learning a Programming Language"},{"location":"Weeks/01/day02-01/#understand-why-you-need-to-learn-a-programming-language","text":"The reason that Python and Go are recommended so often for DevOps engineers is that a lot of the DevOps tooling is written in either Python or Go, which makes sense if you are going to be building, using and maintaing any type of DevOps tools. Now this is important as this will determine really what you should learn and that would likely be the most beneficial skillsets for this career path. Since in the future, we are going to be heavily involved in Kubernetes and Containers, then it's more than likely that choosing Go as your programming language would heavily increase productivity but Python will be as helpful for you. In our ecosystems, we are focusing on deploying EC2 instances on AWS and automating a lot of our tasks and deployments using Terraform so having knowledge on data management for Kubernetes will be beneficial as everything is written in Go. Remember we are not going to be building applications but the goal here is to understand a little more about the programming language so that we can read and understand what those tools are doing and then that can bring opportunities on how we can help on improving our tools. I would also it is also important to know how you interact with those DevOps tools which could be K8s or it could be Terraform and Ansible. These are what we will call config files and this is how you interact with those DevOps tools to make things happen, commonly these are going to be YAML. (We may use the last day of this section to dive a little into YAML)","title":"Understand why you need to learn a programming language."},{"location":"Weeks/01/day02-01/#did-we-just-talk-ourselves-out-of-learning-a-programming-language","text":"Most of the time or depending on the role, you will be helping engineering teams implement DevOps into their workflow, a lot of testing around the application and making sure that the workflow that is built aligns to those DevOps principles we mentioned over the first few days. But in reality, this is going to be a lot of the time troubleshooting an application performance issue or something along those lines. This comes back to my original point and reasoning, the programming language I need to know is the one that the code is written in? If their application is written in NodeJS it won\u2019t help much if you have a Go or Python badge or certification.","title":"Did we just talk ourselves out of learning a programming language?"},{"location":"Weeks/01/day02-01/#why-go","text":"You may ask yourself why is Golangv considered as the next programming language for DevOps and you may find that most Go most definitely has become a very popular programming language in recent years. According to the StackOverflow Survey for 2021, Go came in fourth for the most wanted Programming, scripting and markup languages with Python being top. StackOverflow 2021 Developer Survey \u2013 Most Wanted Link However, as I have also mentioned some of the most known DevOps tools and platforms are written in Go such as Kubernetes, Docker, Grafana and Prometheus and having at least a base knowledge on Go will greatly elevate your understanding when working with those type of tools. What are some of the characteristics of Go that make it great for DevOps?","title":"Why Go"},{"location":"Weeks/01/day02-01/#build-and-deployment-of-go-programs","text":"An advantage of using a language like Python that is interpreted in a DevOps role is that you don\u2019t need to compile a python program before running it. Especially for smaller automation tasks, you don\u2019t want to be slowed down by a build process that requires compilation even though, Go is a compiled programming language, Go compiles directly into machine code . Go is known also for fast compilation times.","title":"Build and Deployment of Go Programs"},{"location":"Weeks/01/day02-01/#go-vs-python-for-devops","text":"Go Programs are statically linked, this means that when you compile a go program everything is included in a single binary executable, no external dependencies will be required that would need to be installed on the remote machine, this makes the deployment of go programs easy, compared to python program that uses external libraries you have to make sure that all those libraries are installed on the remote machine that you wish to run on. Go is a platform-independent language, which means you can produce binary executables for *all the operating systems, Linux, Windows, macOS etc and very easy to do so. With Python, it is not as easy to create these binary executables for particular operating systems. Go is a very performant language, it has fast compilation and fast run time with lower resource usage like CPU and memory especially compared to python, numerous optimizations have been implemented in the Go language that makes it so performant. (Resources below) Unlike Python which often requires the use of third party libraries to implement a particular python program, go includes a standard library that has the majority of functionality that you would need for DevOps built directly into it. This includes functionality file processing, HTTP web services, JSON processing, native support for concurrency and parallelism as well as built-in testing. This is by no way throwing Python under the bus as we will still be touching and seeing python further down the course, however the main reasoning here for choosing Go just right now is so that we can have a broader knowledge on how Go applications are constructed, however in the future you can easiy focus on Python if that's your cup of tea and that's completely valid. Just that for now, we will work with Go just to build general bases on it which will prove to be helpful whenever we work with devops tools that are programmed on this specific language. I will say that once you start fo fully master a programming language it becomes easier to take on other languages. You're probably never going to have a single job in any company anywhere where you don't have to deal with manage, architect, orchestrating, debug JavaScript and Node JS applications so being able to be versatile with our skills will definitely set us up for success.","title":"Go vs Python for DevOps"},{"location":"Weeks/01/day02-01/#resources","text":"StackOverflow 2021 Developer Survey Why we are choosing Golang to learn Jake Wright - Learn Go in 12 minutes Techworld with Nana - Golang full course - 3 hours 24 mins FreeCodeCamp - Learn Go Programming - Golang Tutorial for Beginners Hitesh Choudhary - Complete playlist Now for the next 6 days of this topic my intention is to work through some of the resources listed above and document your notes for each day. You will notice that they are generally around 3 hours as a full course, I wanted to share my complete list so that if you have time you should move ahead and work through each one if time permits. I am not expecting that we will learn a programming language from beginning to end within a week but will definitely be a great tool to start using on our workflows. See you in Next Section .","title":"Resources"},{"location":"Weeks/01/day02-02/","text":"Setting up your DevOps environment for Go & Hello World Before we get into some of the fundamentals of Go we should get Go installed on our workstation and do what every \"learning programming 101\" module teaches us which is to create the Hello World app. As this one is going to be walking through the steps to get Go installed on your workstation we are going to attempt to document the process in pictures so it is can be easily followed along. First of all, let's head on over to go.dev/dl and you will be greeted with some available options for downloads. You probably know which workstation operating system you are running so select the appropriate download and then we can start the installation process. I am using MacOS for this walkthrough, basically, from this next screen, we can leave all the defaults in place for now. (I will note that at the time of writing this was the latest version so screenshots might be out of date) Also note if you do have an older version of Go installed you will have to remove this before installing, Windows has this built into the installer and will remove and install as one. Once finished you should now open a command prompt/terminal and we want to check that we have Go installed. If you do not get the output that we see below then Go is not installed and you will need to retrace your steps. go version Next up we want to check our environment for Go. This is always good to check to make sure your working directories are configured correctly, as you can see below we need to make sure you have the following directory on your system. Did you check? Are you following along? You will probably get something like the below if you try and navigate there. Ok, let's create that directory for ease I am going to use the mkdir command through terminal. We also need to create 3 folders within the Go folder as you will see also below. Now we have Go installed and we have our Go working directory ready for action. We now need an integrated development environment (IDE). Now there are many out there available that you can use but the most common and the one I use is Visual Studio Code or Code. You can learn more about IDEs here . If you have not downloaded and installed VSCode already on your workstation then you can do so by heading here . As you can see below you have your different OS options. Much the same as with the Go installation we are going to download and install and keep the defaults. Once complete you can open VSCode and you can select Open File and navigate to our Go directory that we created above. You may get a popup about trust, read it if you want and then hit Yes, trust the authors. Now you should see the three folders we also created earlier as well and what we want to do now is right click the src folder and create a new folder called Hello Pretty easy stuff I would say up till this point? Now we are going to create our first Go Program with no understanding about anything we put in this next phase. Next create a file called main.go in your hello folder. As soon as you hit enter on the main.go you will be asked if you want to install the Go extension. Go ahead and install those as it will package additional files for you. Once it is done installing, you'll be able to check that the empty pkg file that we made a few steps back now has some new packages inside it: Now let's get this Hello World app going, copy for the following code into your new main.go file and save that. package main import \"fmt\" func main() { fmt.Println(\"Hello #DevOpsTraineeProgram\") } Now lets appreciate that the above might make no sense at all, but we will cover more about functions, packages and more in later days. For now let's run our app. Back in the terminal and in our Hello folder we can now check that all is working. Using the command below we can check to see if our generic learning program is working. go run main.go It doesn't end there though, what if we now want to take our program and run it on other MacOS machines? We can do that by building our binary using the following command go build main.go If we execute this file with ./main instead of go run main as you'll get the following message if you do package main is not in GOROOT See you on Next Section .","title":"2. Setting up your DevOps environment for Go & Hello World"},{"location":"Weeks/01/day02-02/#setting-up-your-devops-environment-for-go-hello-world","text":"Before we get into some of the fundamentals of Go we should get Go installed on our workstation and do what every \"learning programming 101\" module teaches us which is to create the Hello World app. As this one is going to be walking through the steps to get Go installed on your workstation we are going to attempt to document the process in pictures so it is can be easily followed along. First of all, let's head on over to go.dev/dl and you will be greeted with some available options for downloads. You probably know which workstation operating system you are running so select the appropriate download and then we can start the installation process. I am using MacOS for this walkthrough, basically, from this next screen, we can leave all the defaults in place for now. (I will note that at the time of writing this was the latest version so screenshots might be out of date) Also note if you do have an older version of Go installed you will have to remove this before installing, Windows has this built into the installer and will remove and install as one. Once finished you should now open a command prompt/terminal and we want to check that we have Go installed. If you do not get the output that we see below then Go is not installed and you will need to retrace your steps. go version Next up we want to check our environment for Go. This is always good to check to make sure your working directories are configured correctly, as you can see below we need to make sure you have the following directory on your system. Did you check? Are you following along? You will probably get something like the below if you try and navigate there. Ok, let's create that directory for ease I am going to use the mkdir command through terminal. We also need to create 3 folders within the Go folder as you will see also below. Now we have Go installed and we have our Go working directory ready for action. We now need an integrated development environment (IDE). Now there are many out there available that you can use but the most common and the one I use is Visual Studio Code or Code. You can learn more about IDEs here . If you have not downloaded and installed VSCode already on your workstation then you can do so by heading here . As you can see below you have your different OS options. Much the same as with the Go installation we are going to download and install and keep the defaults. Once complete you can open VSCode and you can select Open File and navigate to our Go directory that we created above. You may get a popup about trust, read it if you want and then hit Yes, trust the authors. Now you should see the three folders we also created earlier as well and what we want to do now is right click the src folder and create a new folder called Hello Pretty easy stuff I would say up till this point? Now we are going to create our first Go Program with no understanding about anything we put in this next phase. Next create a file called main.go in your hello folder. As soon as you hit enter on the main.go you will be asked if you want to install the Go extension. Go ahead and install those as it will package additional files for you. Once it is done installing, you'll be able to check that the empty pkg file that we made a few steps back now has some new packages inside it: Now let's get this Hello World app going, copy for the following code into your new main.go file and save that. package main import \"fmt\" func main() { fmt.Println(\"Hello #DevOpsTraineeProgram\") } Now lets appreciate that the above might make no sense at all, but we will cover more about functions, packages and more in later days. For now let's run our app. Back in the terminal and in our Hello folder we can now check that all is working. Using the command below we can check to see if our generic learning program is working. go run main.go It doesn't end there though, what if we now want to take our program and run it on other MacOS machines? We can do that by building our binary using the following command go build main.go If we execute this file with ./main instead of go run main as you'll get the following message if you do package main is not in GOROOT See you on Next Section .","title":"Setting up your DevOps environment for Go &amp; Hello World"},{"location":"Weeks/01/day02-03/","text":"Let's explain the Hello World code How Go works On the Previous Section we walked through getting Go installed on your workstation and we then created our first Go application. In this section, we are going to take a deeper look into the code and understand a few more things about the Go language. What is Compiling? Before we get into the 6 lines of the Hello World code we need to have a bit of an understanding about compiling. Programming languages that we commonly use such as Python, Java, Go and C++ are high-level languages. Meaning they are human-readable but when a machine is trying to execute a program it needs to be in a form that a machine can understand. We have to translate our human-readable code to machine code which is called compiling. From the above you can see what we did on Previous Section here, we created a simple Hello World main.go and we then used the command go build main.go to compile our executable. What are packages? A package is a collection of source files in the same directory that are compiled together. We can simplify this further, a package is a bunch of .go files in the same directory. Remember our Hello folder from Day 8? If and when you get into more complex Go programs you might find that you have folder1 folder2 and folder3 containing different .go files that make up your program with multiple packages. We use packages so we can reuse other peoples code, we don't have to write everything from scratch. Maybe we are wanting a calculator as part of our program, you could probably find an existing Go Package that contains the mathematical functions that you could import into your code saving you a lot of time and effort in the long run. Go encourages you to organise your code in packages so that it is easy to reuse and maintain source code. Hello #DevOpsTraineeProgram Line by Line Now let's take a look at our Hello #DevOpsTraineeProgram main.go file and walk through the lines. In the first line, you have package main which means that this file belongs to a package called main. All .go files need to belong to a package, they should also have package something in the opening line. A package can be named whatever you wish. We have to call this main as this is the starting point of the program that is going to be in this package, this is a rule. (Feel free to further research to understand more regarding this rule.) Whenever we want to compile and execute our code we have to tell the machine where the execution needs to start. We do this by writing a function called main. The machine will look for a function called main to find the entry point of the program. A function is a block of code that can do some specific task for and can be used across the program. You can declare a function with any name using func but in this case we need to name it main as this is where the code starts. Next we are going to look at line 3 of our code, the import, this basically means you want to bring in another package to your main program. fmt is a standard package being used here provided by Go, this package contains the Println() function and because we have imported this we can use this in line 6. There are a number of standard packages you can include in your program and leverage or reuse them in your code saving you the hassle of having to write from scratch. Go Standard Library the Println() that we have here is a way in which to write to a standard output to the terminal whenever the executuable has been executed succesfully. Feel free to change the message in between the () . TLDR Line 1 = This file will be in the package called main and this needs to be called main because includes the entry point of the program. Line 3 = For us to be able to use the Println() function, we have to import the fmt package to use this on line 6. Line 5 = The actual starting point, its the main function. Line 6 = This will let us print \"Hello #DevOpsTraineeProgram\" on our system. See you on Next Section .","title":"3. Let's explain the Hello World code"},{"location":"Weeks/01/day02-03/#lets-explain-the-hello-world-code","text":"","title":"Let's explain the Hello World code"},{"location":"Weeks/01/day02-03/#how-go-works","text":"On the Previous Section we walked through getting Go installed on your workstation and we then created our first Go application. In this section, we are going to take a deeper look into the code and understand a few more things about the Go language.","title":"How Go works"},{"location":"Weeks/01/day02-03/#what-is-compiling","text":"Before we get into the 6 lines of the Hello World code we need to have a bit of an understanding about compiling. Programming languages that we commonly use such as Python, Java, Go and C++ are high-level languages. Meaning they are human-readable but when a machine is trying to execute a program it needs to be in a form that a machine can understand. We have to translate our human-readable code to machine code which is called compiling. From the above you can see what we did on Previous Section here, we created a simple Hello World main.go and we then used the command go build main.go to compile our executable.","title":"What is Compiling?"},{"location":"Weeks/01/day02-03/#what-are-packages","text":"A package is a collection of source files in the same directory that are compiled together. We can simplify this further, a package is a bunch of .go files in the same directory. Remember our Hello folder from Day 8? If and when you get into more complex Go programs you might find that you have folder1 folder2 and folder3 containing different .go files that make up your program with multiple packages. We use packages so we can reuse other peoples code, we don't have to write everything from scratch. Maybe we are wanting a calculator as part of our program, you could probably find an existing Go Package that contains the mathematical functions that you could import into your code saving you a lot of time and effort in the long run. Go encourages you to organise your code in packages so that it is easy to reuse and maintain source code.","title":"What are packages?"},{"location":"Weeks/01/day02-03/#hello-devopstraineeprogram-line-by-line","text":"Now let's take a look at our Hello #DevOpsTraineeProgram main.go file and walk through the lines. In the first line, you have package main which means that this file belongs to a package called main. All .go files need to belong to a package, they should also have package something in the opening line. A package can be named whatever you wish. We have to call this main as this is the starting point of the program that is going to be in this package, this is a rule. (Feel free to further research to understand more regarding this rule.) Whenever we want to compile and execute our code we have to tell the machine where the execution needs to start. We do this by writing a function called main. The machine will look for a function called main to find the entry point of the program. A function is a block of code that can do some specific task for and can be used across the program. You can declare a function with any name using func but in this case we need to name it main as this is where the code starts. Next we are going to look at line 3 of our code, the import, this basically means you want to bring in another package to your main program. fmt is a standard package being used here provided by Go, this package contains the Println() function and because we have imported this we can use this in line 6. There are a number of standard packages you can include in your program and leverage or reuse them in your code saving you the hassle of having to write from scratch. Go Standard Library the Println() that we have here is a way in which to write to a standard output to the terminal whenever the executuable has been executed succesfully. Feel free to change the message in between the () .","title":"Hello #DevOpsTraineeProgram Line by Line"},{"location":"Weeks/01/day02-03/#tldr","text":"Line 1 = This file will be in the package called main and this needs to be called main because includes the entry point of the program. Line 3 = For us to be able to use the Println() function, we have to import the fmt package to use this on line 6. Line 5 = The actual starting point, its the main function. Line 6 = This will let us print \"Hello #DevOpsTraineeProgram\" on our system. See you on Next Section .","title":"TLDR"},{"location":"Weeks/01/day02-04/","text":"The Go Workspace On the Previous Section we briefly covered the Go workspace to get Go up and running to get to the demo of Hello #DevOpsTraineeProgram But we should explain a little more about the Go workspace. Remember we chose the defaults and we then went through and created our Go folder in the GOPATH that was already defined but in reality, this GOPATH can be changed to be whatever you want it to be. If you run echo $GOPATH The output should be similar to mine (with a different username may be) which is: /home/romerocm/go Then within here, we created 3 directories. src , pkg and bin src is where all of your Go programs and projects are stored. This handles namespacing package management for all your Go repositories. This is where you will see on our workstation we have our hello folder for the Hello #DevOpsTraineeProgram project. pkg is where your archived files of packages that are or were installed in programs. This helps to speed up the compiling process based on if the packages being used have been modified. bin is where all of your compiled binaries are stored. Our Hello #DevOpsTraineeProgram is not a complex program so here is an example of a more complex Go Program taken from another great resource worth looking at GoChronicles This page also goes into some great detail about why and how the layout is like this it also goes a little deeper on other folders we have not mentioned GoChronicles Compiling & running code On a Previous Section we also covered a brief introduction to compiling code, but we can go a little deeper here. To run our code we first must compile it. There are three ways to do this within Go. go build go install go run Before we get to the above compile stage we need to take a look at what we get with the Go Installation. When we installed Go this installed something known as Go tools which consist of several programs that let us build and process our Go source files. One of the tools is Go It is worth noting that you can install additional tools that are not in the standard Go installation. If you open your command prompt and type go you should see something like the image below and then you will see \"Additional Help Topics\" below that for now we don't need to worry about those. You might also remember that we have already used at least two of these tools so far on our previous sections. The ones we want to learn more about are build, install and run. go run - This command compiles and runs the main package comprised of the .go files specified on the command line. The command is compiled to a temporary folder. go build - To compile packages and dependencies, compile the package in the current directory. If the main package, will place the executable in the current directory if not then it will place the executable in the pkg folder. go build also enables you to build an executable file for any Go Supported OS platform. go install - The same as go build but will place the executable in the bin folder We have run through go build and go run but feel free to run through them again here if you wish, go install as stated above puts the executable in our bin folder. Hopefully, if you are following along you are watching one of the playlists or videos below. The resources below are likely going to give you a much better understanding of a lot of these areas you need overall while we try to keep everything simple and straight to the point on these sections. Resources StackOverflow 2021 Developer Survey Why we are choosing Golang to learn Jake Wright - Learn Go in 12 minutes Techworld with Nana - Golang full course - 3 hours 24 mins NOT FREE Nigel Poulton Pluralsight - Go Fundamentals - 3 hours 26 mins FreeCodeCamp - Learn Go Programming - Golang Tutorial for Beginners Hitesh Choudhary - Complete playlist See you on Day 11 .","title":"4. The Go Workspace"},{"location":"Weeks/01/day02-04/#the-go-workspace","text":"On the Previous Section we briefly covered the Go workspace to get Go up and running to get to the demo of Hello #DevOpsTraineeProgram But we should explain a little more about the Go workspace. Remember we chose the defaults and we then went through and created our Go folder in the GOPATH that was already defined but in reality, this GOPATH can be changed to be whatever you want it to be. If you run echo $GOPATH The output should be similar to mine (with a different username may be) which is: /home/romerocm/go Then within here, we created 3 directories. src , pkg and bin src is where all of your Go programs and projects are stored. This handles namespacing package management for all your Go repositories. This is where you will see on our workstation we have our hello folder for the Hello #DevOpsTraineeProgram project. pkg is where your archived files of packages that are or were installed in programs. This helps to speed up the compiling process based on if the packages being used have been modified. bin is where all of your compiled binaries are stored. Our Hello #DevOpsTraineeProgram is not a complex program so here is an example of a more complex Go Program taken from another great resource worth looking at GoChronicles This page also goes into some great detail about why and how the layout is like this it also goes a little deeper on other folders we have not mentioned GoChronicles","title":"The Go Workspace"},{"location":"Weeks/01/day02-04/#compiling-running-code","text":"On a Previous Section we also covered a brief introduction to compiling code, but we can go a little deeper here. To run our code we first must compile it. There are three ways to do this within Go. go build go install go run Before we get to the above compile stage we need to take a look at what we get with the Go Installation. When we installed Go this installed something known as Go tools which consist of several programs that let us build and process our Go source files. One of the tools is Go It is worth noting that you can install additional tools that are not in the standard Go installation. If you open your command prompt and type go you should see something like the image below and then you will see \"Additional Help Topics\" below that for now we don't need to worry about those. You might also remember that we have already used at least two of these tools so far on our previous sections. The ones we want to learn more about are build, install and run. go run - This command compiles and runs the main package comprised of the .go files specified on the command line. The command is compiled to a temporary folder. go build - To compile packages and dependencies, compile the package in the current directory. If the main package, will place the executable in the current directory if not then it will place the executable in the pkg folder. go build also enables you to build an executable file for any Go Supported OS platform. go install - The same as go build but will place the executable in the bin folder We have run through go build and go run but feel free to run through them again here if you wish, go install as stated above puts the executable in our bin folder. Hopefully, if you are following along you are watching one of the playlists or videos below. The resources below are likely going to give you a much better understanding of a lot of these areas you need overall while we try to keep everything simple and straight to the point on these sections.","title":"Compiling &amp; running code"},{"location":"Weeks/01/day02-04/#resources","text":"StackOverflow 2021 Developer Survey Why we are choosing Golang to learn Jake Wright - Learn Go in 12 minutes Techworld with Nana - Golang full course - 3 hours 24 mins NOT FREE Nigel Poulton Pluralsight - Go Fundamentals - 3 hours 26 mins FreeCodeCamp - Learn Go Programming - Golang Tutorial for Beginners Hitesh Choudhary - Complete playlist See you on Day 11 .","title":"Resources"},{"location":"Weeks/01/day02-05/","text":"Before we get into the topics for today I want to give a massive shout out to Techworld with Nana and this fantastic concise journey through the fundamentals of Go. On Section 2 we set our environment up, on Section 3 we walked through the Hello #DevOpsTraineeProgram code and on Section 4 ) we looked at our Go workspace and went a little deeper into compiling and running the code. We are now going to take a look into Variables, Constants and Data Types whilst writing a new program. Variables & Constants in Go Let's start by planning our application, I think it would be a good idea to work on a program that tells us how many days we have remain in our #DevOpsTraineeProgram. The first thing to consider here is that as we are building our app and we are welcoming our attendees and we are giving the user feedback on the number of days they have completed we might use the term #DevOpsTraineeProgram many times throughout the program. This is a great use case to make #DevOpsTraineeProgram a variable within our program. Variables are used to store values. Like a little box with our saved information or values. We can then use this variable across the program which also benefits that if this challenge or variable changes then we only have to change this in one place. Meaning we could translate this to other challenges we have in the community by just changing that one variable value. To declare this in our Go Program we define a value by using a keyword for variables. This will live within our func main block of code that you will see later. You can find more about Keywords here. Remember to make sure that your variable names are descriptive. If you declare a variable you must use it or you will get an error, this is to avoid possible dead code, code that is never used. This is the same for packages not used. var challenge = \"#DevOpsTraineeProgram\" With the above set and used as we will see in the next code snippet you can see from the output below that we have used a variable. package main import \"fmt\" func main() { var challenge = \"#DevOpsTraineeProgram\" fmt.Println(\"Welcome to\", challenge, \"\") } You can find the above code snippet on Pastebin You will then see from the below that we built our code with the above example and we got the output shown below. We also know that our challenge is 60 days at least but maybe we'd like to extend it to 90 in the future! If this is the case, we'd want to define a variable to help us be as flexible as possible. However, for our this program and exercise we want to define it as a constant. Constants are like variables, except that their value cannot be changed within code (we can still create a new app later down the line with this same snippet of code and decide to change this constant but this 60 value will not change whilst we are running our application) Adding the const to our code and adding another line of code to print this. package main import \"fmt\" func main() { var challenge = \"#DevOpsTraineeProgram\" const daystotal = 60 fmt.Println(\"Welcome to\", challenge) fmt.Println(\"This is a\", daystotal, \"challenge\") } You can find the above code snippet on Pastebin If we then go through that go build process again and run you will see below the outcome. Finally, and this won't be the end of our program we will come back to this in next Sections to add more functionality. We now want to add another variable for the number of days we have completed the challenge. Below we've added dayscomplete variable with the number of days completed. package main import \"fmt\" func main() { var challenge = \"#DevOpsTraineeProgram\" const daystotal = 60 var dayscomplete = 11 fmt.Println(\"Welcome to\", challenge, \"\") fmt.Println(\"This is a\", daystotal, \"challenge and you have completed\", dayscomplete, \"days\") fmt.Println(\"Great work\") } You can find the above code snippet on Pastebin Let's run through that go build process again or you could just use go run Here are some other examples that I have used to make the code easier to read and edit. We have up till now been using Println but we can simplify this by using Printf by using %v which means we define our variables in order at the end of the line of code. we also use \\n for a line break. I am using %v as this uses a default value but there are other options that can be found here in the fmt package documentation you can find the code example here : package main import \"fmt\" func main() { var challenge = \"#DevOpsTraineeProgram\" const daystotal = 90 var dayscomplete = 11 fmt.Printf(\"Welcome to %v\\n\", challenge) fmt.Printf(\"This is a %v challenge and you have completed %v days\\n\", daystotal, dayscomplete) fmt.Println(\"Great work\") } Variables may also be defined in a simpler format in your code. Instead of defining that it is a var and the type you can code this as follows to get the same functionality but a nice cleaner and simpler look for your code. This will only work for variables though and not constants. func main() { challenge := \"#DevOpsTraineeProgram\" const daystotal = 60 Data Types In the above examples, we have not defined the type of variables, this is because we can give it a value here and Go is smart enough to know what that type is or at least can infer what it is based on the value you have stored. However, if we want a user to input this will require a specific type. We have used Strings and Integers in our code so far. Integers for the number of days and strings are for the name of the challenge. It is also important to note that each data type can do different things and behaves differently. For example, integers can multiply where strings do not. There are four categories Basic type : Numbers, strings, and booleans come under this category. Aggregate type : Array and structs come under this category. Reference type : Pointers, slices, maps, functions, and channels come under this category. Interface type The data type is an important concept in programming. Data type specifies the size and type of variable values. Go is statically typed, meaning that once a variable type is defined, it can only store data of that type. Go has three basic data types: bool : represents a boolean value and is either true or false Numeric : represents integer types, floating-point values, and complex types string : represents a string value I found this resource super detailed on data types Golang by example I would also suggest Techworld with Nana at this point covers in some detail a lot about the data types in Go. If we need to define a type in our variable we can do this like so: var TwitterHandle string var DaysCompleted uint Because Go implies variables where a value is given we can print out those values with the following: fmt.Printf(\"challenge is %T, daystotal is %T, dayscomplete is %T\\n\", conference, daystotal, dayscomplete) There are many different types of integer and float types the links above will cover off these in detail. int = whole numbers unint = positive whole numbers floating point types = numbers that contain a decimal component Next up we are going to start adding some user input functionality to our program so that we are asking how many days have been completed. See you on Next Section .","title":"5. Variables & Constants in Go"},{"location":"Weeks/01/day02-05/#variables-constants-in-go","text":"Let's start by planning our application, I think it would be a good idea to work on a program that tells us how many days we have remain in our #DevOpsTraineeProgram. The first thing to consider here is that as we are building our app and we are welcoming our attendees and we are giving the user feedback on the number of days they have completed we might use the term #DevOpsTraineeProgram many times throughout the program. This is a great use case to make #DevOpsTraineeProgram a variable within our program. Variables are used to store values. Like a little box with our saved information or values. We can then use this variable across the program which also benefits that if this challenge or variable changes then we only have to change this in one place. Meaning we could translate this to other challenges we have in the community by just changing that one variable value. To declare this in our Go Program we define a value by using a keyword for variables. This will live within our func main block of code that you will see later. You can find more about Keywords here. Remember to make sure that your variable names are descriptive. If you declare a variable you must use it or you will get an error, this is to avoid possible dead code, code that is never used. This is the same for packages not used. var challenge = \"#DevOpsTraineeProgram\" With the above set and used as we will see in the next code snippet you can see from the output below that we have used a variable. package main import \"fmt\" func main() { var challenge = \"#DevOpsTraineeProgram\" fmt.Println(\"Welcome to\", challenge, \"\") } You can find the above code snippet on Pastebin You will then see from the below that we built our code with the above example and we got the output shown below. We also know that our challenge is 60 days at least but maybe we'd like to extend it to 90 in the future! If this is the case, we'd want to define a variable to help us be as flexible as possible. However, for our this program and exercise we want to define it as a constant. Constants are like variables, except that their value cannot be changed within code (we can still create a new app later down the line with this same snippet of code and decide to change this constant but this 60 value will not change whilst we are running our application) Adding the const to our code and adding another line of code to print this. package main import \"fmt\" func main() { var challenge = \"#DevOpsTraineeProgram\" const daystotal = 60 fmt.Println(\"Welcome to\", challenge) fmt.Println(\"This is a\", daystotal, \"challenge\") } You can find the above code snippet on Pastebin If we then go through that go build process again and run you will see below the outcome. Finally, and this won't be the end of our program we will come back to this in next Sections to add more functionality. We now want to add another variable for the number of days we have completed the challenge. Below we've added dayscomplete variable with the number of days completed. package main import \"fmt\" func main() { var challenge = \"#DevOpsTraineeProgram\" const daystotal = 60 var dayscomplete = 11 fmt.Println(\"Welcome to\", challenge, \"\") fmt.Println(\"This is a\", daystotal, \"challenge and you have completed\", dayscomplete, \"days\") fmt.Println(\"Great work\") } You can find the above code snippet on Pastebin Let's run through that go build process again or you could just use go run Here are some other examples that I have used to make the code easier to read and edit. We have up till now been using Println but we can simplify this by using Printf by using %v which means we define our variables in order at the end of the line of code. we also use \\n for a line break. I am using %v as this uses a default value but there are other options that can be found here in the fmt package documentation you can find the code example here : package main import \"fmt\" func main() { var challenge = \"#DevOpsTraineeProgram\" const daystotal = 90 var dayscomplete = 11 fmt.Printf(\"Welcome to %v\\n\", challenge) fmt.Printf(\"This is a %v challenge and you have completed %v days\\n\", daystotal, dayscomplete) fmt.Println(\"Great work\") } Variables may also be defined in a simpler format in your code. Instead of defining that it is a var and the type you can code this as follows to get the same functionality but a nice cleaner and simpler look for your code. This will only work for variables though and not constants. func main() { challenge := \"#DevOpsTraineeProgram\" const daystotal = 60","title":"Variables &amp; Constants in Go"},{"location":"Weeks/01/day02-05/#data-types","text":"In the above examples, we have not defined the type of variables, this is because we can give it a value here and Go is smart enough to know what that type is or at least can infer what it is based on the value you have stored. However, if we want a user to input this will require a specific type. We have used Strings and Integers in our code so far. Integers for the number of days and strings are for the name of the challenge. It is also important to note that each data type can do different things and behaves differently. For example, integers can multiply where strings do not. There are four categories Basic type : Numbers, strings, and booleans come under this category. Aggregate type : Array and structs come under this category. Reference type : Pointers, slices, maps, functions, and channels come under this category. Interface type The data type is an important concept in programming. Data type specifies the size and type of variable values. Go is statically typed, meaning that once a variable type is defined, it can only store data of that type. Go has three basic data types: bool : represents a boolean value and is either true or false Numeric : represents integer types, floating-point values, and complex types string : represents a string value I found this resource super detailed on data types Golang by example I would also suggest Techworld with Nana at this point covers in some detail a lot about the data types in Go. If we need to define a type in our variable we can do this like so: var TwitterHandle string var DaysCompleted uint Because Go implies variables where a value is given we can print out those values with the following: fmt.Printf(\"challenge is %T, daystotal is %T, dayscomplete is %T\\n\", conference, daystotal, dayscomplete) There are many different types of integer and float types the links above will cover off these in detail. int = whole numbers unint = positive whole numbers floating point types = numbers that contain a decimal component Next up we are going to start adding some user input functionality to our program so that we are asking how many days have been completed. See you on Next Section .","title":"Data Types"}]}